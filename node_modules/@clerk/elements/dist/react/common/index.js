"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/react/common/index.ts
var common_exports = {};
__export(common_exports, {
  Connection: () => Connection,
  Field: () => Field,
  FieldError: () => FieldError,
  FieldState: () => FieldState,
  GlobalError: () => GlobalError,
  Icon: () => Icon,
  Input: () => Input,
  Label: () => Label,
  Loading: () => Loading,
  Submit: () => Submit
});
module.exports = __toCommonJS(common_exports);
var import_client_only = require("client-only");

// src/react/common/form/field.tsx
var import_react_form3 = require("@radix-ui/react-form");
var React7 = __toESM(require("react"));

// src/internals/machines/form/form.context.ts
var import_react = require("@xstate/react");

// src/internals/machines/form/form.machine.ts
var import_error = require("@clerk/shared/error");
var import_underscore = require("@clerk/shared/underscore");
var import_xstate = require("xstate");

// src/internals/errors/index.ts
var ClerkElementsErrorBase = class extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.clerkError = true;
    this.clerkElementsError = true;
    this.name = "ClerkElementsError";
    this.rawMessage = message;
  }
  toString() {
    return `[${this.name}]
Code: ${this.code}
Message: ${this.message}`;
  }
};
var ClerkElementsError = class _ClerkElementsError extends ClerkElementsErrorBase {
  static fromAPIError(error) {
    return new _ClerkElementsError(
      error.code.toString(),
      // @ts-expect-error - Expected that longMessage isn't a property of MetamaskError
      error.longMessage || error.message
    );
  }
  constructor(code, message) {
    super(code, message);
    this.name = "ClerkElementsError";
  }
};
var ClerkElementsRuntimeError = class extends ClerkElementsErrorBase {
  constructor(message) {
    super("elements_runtime_error", message);
    this.name = "ClerkElementsRuntimeError";
  }
};
var ClerkElementsFieldError = class _ClerkElementsFieldError extends ClerkElementsErrorBase {
  constructor(code, message) {
    super(code, message);
    this.matchFn = () => true;
    this.name = "ClerkElementsFieldError";
  }
  static fromAPIError(error) {
    return new _ClerkElementsFieldError(error.code, error.longMessage || error.message);
  }
  get validityState() {
    return this.code;
  }
  get forceMatch() {
    return true;
  }
};

// src/internals/machines/form/form.machine.ts
var FormMachine = (0, import_xstate.setup)({
  actions: {
    setGlobalErrors: (0, import_xstate.assign)({
      errors: (_, params) => [...params.errors]
    }),
    setFieldFeedback: (0, import_xstate.assign)({
      fields: ({ context }, params) => {
        if (!params.name) {
          throw new Error("Field name is required");
        }
        if (context.fields.has(params.name)) {
          context.fields.get(params.name).feedback = params.feedback;
        }
        return context.fields;
      }
    })
  },
  types: {}
}).createMachine({
  id: "Form",
  context: () => ({
    defaultValues: /* @__PURE__ */ new Map(),
    errors: [],
    fields: /* @__PURE__ */ new Map(),
    progressive: false
  }),
  on: {
    "ERRORS.SET": {
      actions: (0, import_xstate.enqueueActions)(({ enqueue, event }) => {
        var _a, _b, _c;
        const isClerkAPIError = (err) => "meta" in err;
        if ((0, import_error.isKnownError)(event.error)) {
          const fields = {};
          const globalErrors = [];
          const errors = (0, import_error.isClerkAPIResponseError)(event.error) ? (_a = event.error) == null ? void 0 : _a.errors : [event.error];
          for (const error of errors) {
            const name = isClerkAPIError(error) ? (0, import_underscore.snakeToCamel)((_b = error.meta) == null ? void 0 : _b.paramName) : null;
            if (!name || (0, import_error.isMetamaskError)(error)) {
              globalErrors.push(ClerkElementsError.fromAPIError(error));
              continue;
            }
            if (!fields[name]) {
              fields[name] = [];
            }
            (_c = fields[name]) == null ? void 0 : _c.push(ClerkElementsFieldError.fromAPIError(error));
          }
          enqueue({
            type: "setGlobalErrors",
            params: {
              errors: globalErrors
            }
          });
          for (const field in fields) {
            enqueue({
              type: "setFieldFeedback",
              params: {
                name: field,
                feedback: {
                  type: "error",
                  message: fields[field][0]
                }
              }
            });
          }
        }
      })
    },
    "ERRORS.CLEAR": {
      actions: (0, import_xstate.assign)({
        errors: () => []
      })
    },
    "FIELD.ADD": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          event.field.value = event.field.value || context.defaultValues.get(event.field.name) || void 0;
          context.fields.set(event.field.name, event.field);
          return context.fields;
        }
      })
    },
    "FIELD.UPDATE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.checked = event.field.checked;
            field.disabled = event.field.disabled || false;
            field.value = event.field.value;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.DISABLE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.disabled = true;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.ENABLE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.disabled = false;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.REMOVE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          context.fields.delete(event.field.name);
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.SET": {
      actions: [
        {
          type: "setFieldFeedback",
          params: ({ event }) => event.field
        }
      ]
    },
    "FIELD.FEEDBACK.CLEAR": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          if (context.fields.has(event.field.name)) {
            context.fields.get(event.field.name).feedback = void 0;
          }
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.CLEAR.ALL": {
      actions: (0, import_xstate.assign)({
        fields: ({ context }) => {
          context.fields.forEach((field) => {
            field.feedback = void 0;
          });
          return context.fields;
        }
      })
    },
    MARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)(({ event }) => {
        const missing = new Set(event.missing);
        return {
          defaultValues: event.defaultValues,
          hidden: /* @__PURE__ */ new Set([...event.required.filter((f) => !missing.has(f)), ...event.optional]),
          missing,
          optional: new Set(event.optional),
          progressive: true,
          required: new Set(event.required)
        };
      })
    },
    UNMARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)({
        defaultValues: /* @__PURE__ */ new Map(),
        hidden: void 0,
        missing: void 0,
        optional: void 0,
        progressive: false,
        required: void 0
      })
    },
    PREFILL_DEFAULT_VALUES: {
      actions: (0, import_xstate.assign)(({ event }) => {
        return {
          defaultValues: event.defaultValues
        };
      })
    }
  }
});

// src/internals/utils/inspector/index.ts
var inspect;
if (false) {
  inspect = (_a = getBrowserInspector()) != null ? _a : getConsoleInspector();
}

// src/internals/machines/form/form.context.ts
var FormMachineContext = (0, import_react.createActorContext)(FormMachine, { inspect });
var FormStoreProvider = FormMachineContext.Provider;
var useFormStore = FormMachineContext.useActorRef;
var useFormSelector = FormMachineContext.useSelector;
var globalErrorsSelector = (state) => state.context.errors;
var fieldValueSelector = (name) => (state) => {
  var _a;
  return name ? (_a = state.context.fields.get(name)) == null ? void 0 : _a.value : "";
};
var fieldHasValueSelector = (name) => (state) => Boolean(fieldValueSelector(name)(state));
var fieldFeedbackSelector = (name) => (state) => {
  var _a;
  return name ? (_a = state.context.fields.get(name)) == null ? void 0 : _a.feedback : void 0;
};

// src/react/common/form/hooks/use-field-feedback.ts
function useFieldFeedback({ name }) {
  const feedback = useFormSelector(fieldFeedbackSelector(name));
  return {
    feedback
  };
}

// src/react/common/form/hooks/use-field.ts
function useField({ name }) {
  const hasValue = useFormSelector(fieldHasValueSelector(name));
  const { feedback } = useFieldFeedback({ name });
  const shouldBeHidden = false;
  const hasError = feedback ? feedback.type === "error" : false;
  return {
    hasValue,
    props: {
      "data-hidden": shouldBeHidden ? true : void 0,
      serverInvalid: hasError
    }
  };
}

// src/react/common/form/hooks/use-field-context.ts
var React = __toESM(require("react"));
var FieldContext = React.createContext(null);
var useFieldContext = () => React.useContext(FieldContext);

// src/react/common/form/types.ts
var FIELD_STATES = {
  success: "success",
  error: "error",
  idle: "idle",
  warning: "warning",
  info: "info"
};

// src/react/common/form/hooks/use-field-state.ts
function useFieldState({ name }) {
  const { feedback } = useFieldFeedback({ name });
  const hasValue = useFormSelector(fieldHasValueSelector(name));
  let state = FIELD_STATES.idle;
  if (!hasValue) {
    state = FIELD_STATES.idle;
  }
  switch (feedback == null ? void 0 : feedback.type) {
    case "error":
      state = FIELD_STATES.error;
      break;
    case "warning":
      state = FIELD_STATES.warning;
      break;
    case "info":
      state = FIELD_STATES.info;
      break;
    case "success":
      state = FIELD_STATES.success;
      break;
    default:
      break;
  }
  return {
    state
  };
}

// src/react/common/form/hooks/use-global-errors.ts
function useGlobalErrors() {
  const errors = useFormSelector(globalErrorsSelector);
  return {
    errors
  };
}

// src/react/common/form/hooks/use-input.tsx
var import_react_form2 = require("@radix-ui/react-form");
var React6 = __toESM(require("react"));

// src/react/hooks/use-password.hook.ts
var import_shared = require("@clerk/shared");
var import_react2 = require("@clerk/shared/react");
var React2 = __toESM(require("react"));

// src/react/utils/generate-password-error-text.ts
var errorMessages = {
  max_length: ["less than %length% characters", "length"],
  min_length: ["%length% or more characters", "length"],
  require_numbers: "a number",
  require_lowercase: "a lowercase letter",
  require_uppercase: "an uppercase letter",
  require_special_char: "a special character"
};
var createListFormat = (message) => {
  let messageWithPrefix;
  if ("ListFormat" in Intl) {
    const formatter = new Intl.ListFormat("en", { style: "long", type: "conjunction" });
    messageWithPrefix = formatter.format(message);
  } else {
    messageWithPrefix = message.join(", ");
  }
  return messageWithPrefix;
};
function buildErrorTuple(key, config) {
  switch (key) {
    case "max_length":
      return [key, { max_length: config.max_length }];
    case "min_length":
      return [key, { min_length: config.min_length }];
    case "require_special_char":
      return [key, { allowed_special_characters: config.allowed_special_characters }];
    default:
      return key;
  }
}
var generatePasswordErrorText = ({ config, failedValidations }) => {
  const codes = [];
  if (!failedValidations || Object.keys(failedValidations).length === 0) {
    return {
      codes,
      message: ""
    };
  }
  const hasMinLengthError = (failedValidations == null ? void 0 : failedValidations.min_length) || false;
  const messages = Object.entries(failedValidations).filter((k) => hasMinLengthError ? k[0] === "min_length" : true).filter(([, v]) => !!v).map(([k]) => {
    const entry = k;
    const errorTuple = buildErrorTuple(entry, config);
    codes.push(errorTuple);
    const errorKey = errorMessages[entry];
    if (Array.isArray(errorKey)) {
      const [msg, replaceValue] = errorKey;
      return msg.replace(`%${replaceValue}%`, config[k]);
    }
    return errorKey;
  });
  const messageWithPrefix = createListFormat(messages);
  return {
    codes,
    message: `Your password must contain ${messageWithPrefix}.`
  };
};

// src/react/hooks/use-password.hook.ts
var usePassword = (callbacks) => {
  var _a;
  const clerk = (0, import_react2.useClerk)();
  const passwordSettings = (_a = clerk.__unstable__environment) == null ? void 0 : _a.userSettings.passwordSettings;
  const { disable_hibp, min_zxcvbn_strength, show_zxcvbn, ...config } = passwordSettings || {};
  const {
    onValidationError = import_shared.noop,
    onValidationSuccess = import_shared.noop,
    onValidationWarning = import_shared.noop,
    onValidationInfo = import_shared.noop,
    onValidationComplexity
  } = callbacks || {};
  const onValidate = React2.useCallback(
    (res) => {
      var _a2, _b, _c;
      if (res.complexity) {
        if (Object.values(res == null ? void 0 : res.complexity).length > 0) {
          const { message, codes } = generatePasswordErrorText({
            config,
            failedValidations: res.complexity
          });
          if ((_a2 = res.complexity) == null ? void 0 : _a2.min_length) {
            return onValidationInfo(message, codes);
          }
          return onValidationError(message, codes);
        }
      }
      if (((_b = res == null ? void 0 : res.strength) == null ? void 0 : _b.state) === "fail") {
        const keys = res.strength.keys;
        const error = keys.map((key) => get(zxcvbnKeys, key)).join(" ");
        return onValidationError(error, keys);
      }
      if (((_c = res == null ? void 0 : res.strength) == null ? void 0 : _c.state) === "pass") {
        const keys = res.strength.keys;
        const error = keys.map((key) => get(zxcvbnKeys, key)).join(" ");
        return onValidationWarning(error, keys);
      }
      return onValidationSuccess();
    },
    [callbacks, config]
  );
  const validatePassword = React2.useMemo(() => {
    return (password) => {
      return clerk.client.signUp.validatePassword(password, {
        onValidation: onValidate,
        onValidationComplexity
      });
    };
  }, [onValidate]);
  return {
    validatePassword
  };
};
var get = (t, path) => path.split(".").reduce((r, k) => r == null ? void 0 : r[k], t);
var zxcvbnKeys = {
  unstable__errors: {
    zxcvbn: {
      couldBeStronger: "Your password works, but could be stronger. Try adding more characters.",
      goodPassword: "Your password meets all the necessary requirements.",
      notEnough: "Your password is not strong enough.",
      suggestions: {
        allUppercase: "Capitalize some, but not all letters.",
        anotherWord: "Add more words that are less common.",
        associatedYears: "Avoid years that are associated with you.",
        capitalization: "Capitalize more than the first letter.",
        dates: "Avoid dates and years that are associated with you.",
        l33t: "Avoid predictable letter substitutions like '@' for 'a'.",
        longerKeyboardPattern: "Use longer keyboard patterns and change typing direction multiple times.",
        noNeed: "You can create strong passwords without using symbols, numbers, or uppercase letters.",
        pwned: "If you use this password elsewhere, you should change it.",
        recentYears: "Avoid recent years.",
        repeated: "Avoid repeated words and characters.",
        reverseWords: "Avoid reversed spellings of common words.",
        sequences: "Avoid common character sequences.",
        useWords: "Use multiple words, but avoid common phrases."
      },
      warnings: {
        common: "This is a commonly used password.",
        commonNames: "Common names and surnames are easy to guess.",
        dates: "Dates are easy to guess.",
        extendedRepeat: 'Repeated character patterns like "abcabcabc" are easy to guess.',
        keyPattern: "Short keyboard patterns are easy to guess.",
        namesByThemselves: "Single names or surnames are easy to guess.",
        pwned: "Your password was exposed by a data breach on the Internet.",
        recentYears: "Recent years are easy to guess.",
        sequences: 'Common character sequences like "abc" are easy to guess.',
        similarToCommon: "This is similar to a commonly used password.",
        simpleRepeat: 'Repeated characters like "aaa" are easy to guess.',
        straightRow: "Straight rows of keys on your keyboard are easy to guess.",
        topHundred: "This is a frequently used password.",
        topTen: "This is a heavily used password.",
        userInputs: "There should not be any personal or page related data.",
        wordByItself: "Single words are easy to guess."
      }
    }
  }
};

// src/react/common/form/otp.tsx
var import_react_form = require("@radix-ui/react-form");
var React3 = __toESM(require("react"));
var import_jsx_runtime = require("react/jsx-runtime");
var ZERO = [0, 0];
var OUTSIDE = [-1, -1];
var OTP_LENGTH_DEFAULT = 6;
var PASSWORD_MANAGER_OFFSET_DEFAULT = 40;
var OTPInput = React3.forwardRef(function OTPInput2(props, ref) {
  const { render, length, autoSubmit, ...rest } = props;
  const hasRenderProp = typeof render !== "undefined";
  if (hasRenderProp) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      OTPInputSegmented,
      {
        ...rest,
        ref,
        render,
        length,
        autoSubmit
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    OTPInputStandard,
    {
      ...rest,
      ref,
      length,
      autoSubmit
    }
  );
});
var OTPInputStandard = React3.forwardRef(
  function OTPInput3(props, ref) {
    const { length = OTP_LENGTH_DEFAULT, autoSubmit = false, ...rest } = props;
    const innerRef = React3.useRef(null);
    React3.useImperativeHandle(ref, () => innerRef.current, []);
    React3.useEffect(() => {
      var _a, _b;
      if (String(props.value).length === length && autoSubmit) {
        (_b = (_a = innerRef.current) == null ? void 0 : _a.form) == null ? void 0 : _b.requestSubmit();
      }
    }, [props.value, length, autoSubmit]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_react_form.Control,
      {
        ref: innerRef,
        ...rest,
        "data-otp-input-standard": true
      }
    );
  }
);
var OTPInputSegmented = React3.forwardRef(
  function OTPInput4(props, ref) {
    const {
      className: userProvidedClassName,
      render,
      length = OTP_LENGTH_DEFAULT,
      autoSubmit = false,
      passwordManagerOffset = PASSWORD_MANAGER_OFFSET_DEFAULT,
      ...rest
    } = props;
    const innerRef = React3.useRef(null);
    const [selectionRange, setSelectionRange] = React3.useState(props.autoFocus ? ZERO : OUTSIDE);
    const [isHovering, setIsHovering] = React3.useState(false);
    const isFocused = () => document.activeElement === innerRef.current;
    React3.useImperativeHandle(ref, () => innerRef.current, []);
    React3.useLayoutEffect(() => {
      if (document.activeElement !== innerRef.current) {
        return;
      }
      setSelectionRange((cur) => selectionRangeUpdater(cur, innerRef));
    }, [props.value]);
    React3.useEffect(() => {
      function onSelectionChange() {
        if (!isFocused()) {
          return;
        }
        setSelectionRange((cur) => selectionRangeUpdater(cur, innerRef));
      }
      document.addEventListener("selectionchange", onSelectionChange, { capture: true });
      return () => document.removeEventListener("selectionchange", onSelectionChange);
    }, []);
    React3.useEffect(() => {
      var _a, _b;
      if (String(props.value).length === length && autoSubmit) {
        (_b = (_a = innerRef.current) == null ? void 0 : _a.form) == null ? void 0 : _b.requestSubmit();
      }
    }, [props.value, length, autoSubmit]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "div",
      {
        "data-otp-input-wrapper": true,
        style: wrapperStyle,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", { children: `
      input[data-otp-input-segmented]::selection {
        color: transparent;
        background-color: transparent;
      }
      ` }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_react_form.Control,
            {
              "data-otp-input-segmented": true,
              ref: innerRef,
              ...rest,
              onFocus: (event) => {
                var _a;
                if (innerRef.current) {
                  const start = Math.min(innerRef.current.value.length, length - 1);
                  const end = innerRef.current.value.length;
                  innerRef.current.setSelectionRange(start, end);
                  setSelectionRange([start, end]);
                }
                (_a = rest == null ? void 0 : rest.onFocus) == null ? void 0 : _a.call(rest, event);
              },
              onBlur: (event) => {
                var _a;
                setSelectionRange([-1, -1]);
                (_a = rest == null ? void 0 : rest.onBlur) == null ? void 0 : _a.call(rest, event);
              },
              onMouseOver: (event) => {
                var _a;
                if (!isFocused()) {
                  setIsHovering(true);
                }
                (_a = props.onMouseOver) == null ? void 0 : _a.call(props, event);
              },
              onMouseLeave: (event) => {
                var _a;
                setIsHovering(false);
                (_a = props.onMouseLeave) == null ? void 0 : _a.call(props, event);
              },
              style: {
                ...inputStyle,
                clipPath: `inset(0 calc(1ch + ${passwordManagerOffset}px) 0 0)`,
                width: `calc(100% + 1ch + ${passwordManagerOffset}px)`
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            "div",
            {
              className: userProvidedClassName,
              "aria-hidden": true,
              style: segmentWrapperStyle,
              children: Array.from({ length }).map((_, i) => {
                var _a, _b;
                const isHovered = isHovering && !isFocused();
                const isCursor = selectionRange[0] === selectionRange[1] && selectionRange[0] === i;
                const isSelected = ((_a = selectionRange[0]) != null ? _a : -1) <= i && ((_b = selectionRange[1]) != null ? _b : -1) > i;
                return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(React3.Fragment, { children: render({
                  value: String(props.value)[i] || "",
                  status: isHovered ? "hovered" : isCursor ? "cursor" : isSelected ? "selected" : "none",
                  index: i
                }) }, `otp-segment-${i}`);
              })
            }
          )
        ]
      }
    );
  }
);
function selectionRangeUpdater(cur, inputRef) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  let updated = [
    (_b = (_a = inputRef.current) == null ? void 0 : _a.selectionStart) != null ? _b : 0,
    (_d = (_c = inputRef.current) == null ? void 0 : _c.selectionEnd) != null ? _d : 0,
    (_f = (_e = inputRef.current) == null ? void 0 : _e.selectionDirection) != null ? _f : null
  ];
  if (cur[0] === updated[0] && cur[1] === updated[1]) {
    return cur;
  }
  if (updated[0] === 0 && updated[1] === 1) {
    updated[2] = "forward";
  }
  if (updated[0] === updated[1]) {
    if (updated[0] > 0 && cur[0] === updated[0] && cur[1] === updated[0] + 1) {
      updated = [updated[0] - 1, updated[1], "backward"];
    } else if (typeof ((_g = inputRef.current) == null ? void 0 : _g.value[updated[0]]) !== "undefined") {
      updated = [updated[0], updated[1] + 1, "backward"];
    } else if (updated[0] >= OTP_LENGTH_DEFAULT) {
      updated = [updated[0] - 1, updated[1], "backward"];
    }
  }
  (_i = inputRef.current) == null ? void 0 : _i.setSelectionRange(updated[0], updated[1], (_h = updated[2]) != null ? _h : void 0);
  return [updated[0], updated[1]];
}
var wrapperStyle = {
  position: "relative",
  userSelect: "none"
};
var inputStyle = {
  display: "block",
  background: "transparent",
  opacity: 0,
  outline: "transparent solid 0px",
  appearance: "none",
  color: "transparent",
  position: "absolute",
  inset: 0,
  caretColor: "transparent",
  border: "0px solid transparent",
  // width is handled inline
  height: "100%",
  letterSpacing: "-1rem"
};
var segmentWrapperStyle = {
  zIndex: 1,
  pointerEvents: "none"
};

// src/react/common/form/utils/enrich-field-state.ts
function enrichFieldState(validity, fieldState) {
  return (validity == null ? void 0 : validity.valid) === false ? FIELD_STATES.error : fieldState;
}

// src/react/common/form/utils/determine-input-type-from-name.ts
function determineInputTypeFromName(name) {
  if (name === "password" || name === "confirmPassword" || name === "currentPassword" || name === "newPassword") {
    return "password";
  }
  if (name === "emailAddress") {
    return "email";
  }
  if (name === "phoneNumber") {
    return "tel";
  }
  if (name === "code") {
    return "otp";
  }
  if (name === "backup_code") {
    return "backup_code";
  }
  return "text";
}

// src/react/common/form/hooks/use-previous.ts
var React4 = __toESM(require("react"));
function usePrevious(value) {
  const ref = React4.useRef();
  React4.useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}

// src/react/common/form/hooks/use-validity-state-context.ts
var React5 = __toESM(require("react"));
var ValidityStateContext = React5.createContext(void 0);
var useValidityStateContext = () => React5.useContext(ValidityStateContext);

// src/react/common/form/hooks/use-input.tsx
function useInput({
  name: inputName,
  value: providedValue,
  checked: providedChecked,
  onChange: onChangeProp,
  onBlur: onBlurProp,
  onFocus: onFocusProp,
  type: inputType,
  ...passthroughProps
}) {
  const fieldContext = useFieldContext();
  const rawName = inputName || (fieldContext == null ? void 0 : fieldContext.name);
  const name = rawName === "backup_code" ? "code" : rawName;
  const { state: fieldState } = useFieldState({ name });
  const validity = useValidityStateContext();
  if (!rawName || !name) {
    throw new Error("Clerk: <Input /> must be wrapped in a <Field> component or have a name prop.");
  }
  const ref = useFormStore();
  const [hasPassedValiation, setHasPassedValidation] = React6.useState(false);
  const { validatePassword } = usePassword({
    onValidationComplexity: (hasPassed) => setHasPassedValidation(hasPassed),
    onValidationSuccess: () => {
      ref.send({
        type: "FIELD.FEEDBACK.SET",
        field: { name, feedback: { type: "success", message: "Your password meets all the necessary requirements." } }
      });
    },
    onValidationError: (error, codes) => {
      if (error) {
        ref.send({
          type: "FIELD.FEEDBACK.SET",
          field: {
            name,
            feedback: {
              type: "error",
              message: new ClerkElementsFieldError("password-validation-error", error),
              codes
            }
          }
        });
      }
    },
    onValidationWarning: (warning, codes) => ref.send({
      type: "FIELD.FEEDBACK.SET",
      field: { name, feedback: { type: "warning", message: warning, codes } }
    }),
    onValidationInfo: (info, codes) => {
      ref.send({
        type: "FIELD.FEEDBACK.SET",
        field: {
          name,
          feedback: {
            type: "info",
            message: info,
            codes
          }
        }
      });
    }
  });
  const value = useFormSelector(fieldValueSelector(name));
  const prevValue = usePrevious(value);
  const hasValue = Boolean(value);
  const type = inputType != null ? inputType : determineInputTypeFromName(rawName);
  let nativeFieldType = type;
  let shouldValidatePassword = false;
  if (type === "password" || type === "text") {
    shouldValidatePassword = Boolean(passthroughProps.validatePassword);
  }
  if (nativeFieldType === "otp" || nativeFieldType === "backup_code") {
    nativeFieldType = "text";
  }
  React6.useEffect(() => {
    if (!name) {
      return;
    }
    ref.send({
      type: "FIELD.ADD",
      field: { name, type: nativeFieldType, value: providedValue, checked: providedChecked }
    });
    return () => ref.send({ type: "FIELD.REMOVE", field: { name } });
  }, [ref]);
  React6.useEffect(() => {
    if (!name) {
      return;
    }
    if (type === "checkbox" && providedChecked !== void 0 || type !== "checkbox" && providedValue !== void 0) {
      ref.send({
        type: "FIELD.UPDATE",
        field: { name, value: providedValue, checked: providedChecked }
      });
    }
  }, [name, type, ref, providedValue, providedChecked]);
  const onChange = React6.useCallback(
    (event) => {
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (!name) {
        return;
      }
      ref.send({ type: "FIELD.UPDATE", field: { name, value: event.target.value, checked: event.target.checked } });
      if (shouldValidatePassword) {
        validatePassword(event.target.value);
      }
    },
    [ref, name, onChangeProp, shouldValidatePassword, validatePassword]
  );
  const onBlur = React6.useCallback(
    (event) => {
      onBlurProp == null ? void 0 : onBlurProp(event);
      if (shouldValidatePassword && event.target.value !== prevValue) {
        validatePassword(event.target.value);
      }
    },
    [onBlurProp, shouldValidatePassword, validatePassword, prevValue]
  );
  const onFocus = React6.useCallback(
    (event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      if (shouldValidatePassword && event.target.value !== prevValue) {
        validatePassword(event.target.value);
      }
    },
    [onFocusProp, shouldValidatePassword, validatePassword, prevValue]
  );
  const shouldBeHidden = false;
  const Element = type === "otp" ? OTPInput : import_react_form2.Control;
  let props = {};
  if (type === "otp") {
    const p = passthroughProps;
    const length = p.length || OTP_LENGTH_DEFAULT;
    props = {
      "data-otp-input": true,
      autoComplete: "one-time-code",
      inputMode: "numeric",
      pattern: `[0-9]{${length}}`,
      minLength: length,
      maxLength: length,
      onChange: (event) => {
        event.currentTarget.value = event.currentTarget.value.replace(/\D+/g, "");
        onChange(event);
      },
      type: "text",
      spellCheck: false
    };
  } else if (type === "backup_code") {
    props = {
      autoComplete: "off",
      type: "text",
      spellCheck: false
    };
  } else if (type === "password" && shouldValidatePassword) {
    props = {
      "data-has-passed-validation": hasPassedValiation ? true : void 0
    };
  }
  const { validatePassword: _1, ...rest } = passthroughProps;
  return {
    Element,
    props: {
      type,
      value: value != null ? value : "",
      onChange,
      onBlur,
      onFocus,
      "data-hidden": shouldBeHidden ? true : void 0,
      "data-has-value": hasValue ? true : void 0,
      "data-state": enrichFieldState(validity, fieldState),
      ...props,
      ...rest
    }
  };
}

// src/react/common/form/field.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var DISPLAY_NAME = "ClerkElementsField";
var DISPLAY_NAME_INNER = "ClerkElementsFieldInner";
var Field = React7.forwardRef(({ alwaysShow, ...rest }, forwardedRef) => {
  var _a;
  const formRef = useFormStore();
  const formCtx = formRef.getSnapshot().context;
  const isHiddenField = formCtx.progressive && Boolean((_a = formCtx.hidden) == null ? void 0 : _a.has(rest.name));
  const shouldHide = alwaysShow ? false : isHiddenField;
  return shouldHide ? null : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(FieldContext.Provider, { value: { name: rest.name }, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    FieldInner,
    {
      ...rest,
      ref: forwardedRef
    }
  ) });
});
Field.displayName = DISPLAY_NAME;
var FieldInner = React7.forwardRef((props, forwardedRef) => {
  const { children, ...rest } = props;
  const field = useField({ name: rest.name });
  const { state: fieldState } = useFieldState({ name: rest.name });
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    import_react_form3.Field,
    {
      ...field.props,
      ...rest,
      ref: forwardedRef,
      children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react_form3.ValidityState, { children: (validity) => {
        const enrichedFieldState = enrichFieldState(validity, fieldState);
        return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ValidityStateContext.Provider, { value: validity, children: typeof children === "function" ? children(enrichedFieldState) : children });
      } })
    }
  );
});
FieldInner.displayName = DISPLAY_NAME_INNER;

// src/react/common/form/field-error.tsx
var import_react_form4 = require("@radix-ui/react-form");
var import_react_slot = require("@radix-ui/react-slot");
var React9 = __toESM(require("react"));

// src/react/utils/is-react-fragment.ts
var React8 = __toESM(require("react"));
function isReactFragment(node) {
  return React8.isValidElement(node) && node.type === React8.Fragment;
}

// src/react/common/form/field-error.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var DISPLAY_NAME2 = "ClerkElementsFieldError";
var FieldError = React9.forwardRef(
  ({ asChild = false, children, code, name, ...rest }, forwardedRef) => {
    const fieldContext = useFieldContext();
    const rawFieldName = (fieldContext == null ? void 0 : fieldContext.name) || name;
    const fieldName = rawFieldName === "backup_code" ? "code" : rawFieldName;
    const { feedback } = useFieldFeedback({ name: fieldName });
    if (!((feedback == null ? void 0 : feedback.type) === "error")) {
      return null;
    }
    const error = feedback.message;
    if (!error) {
      return null;
    }
    const Comp = asChild ? import_react_slot.Slot : "span";
    const child = typeof children === "function" ? children(error) : children;
    if (isReactFragment(child)) {
      throw new ClerkElementsRuntimeError("<FieldError /> cannot render a Fragment as a child.");
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      import_react_form4.FormMessage,
      {
        "data-error-code": error.code,
        ...rest,
        ref: forwardedRef,
        asChild: true,
        children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Comp, { children: child || error.message })
      }
    );
  }
);
FieldError.displayName = DISPLAY_NAME2;

// src/react/common/form/field-state.tsx
var DISPLAY_NAME3 = "ClerkElementsFieldState";
function FieldState({ children }) {
  const field = useFieldContext();
  const { feedback } = useFieldFeedback({ name: field == null ? void 0 : field.name });
  const { state } = useFieldState({ name: field == null ? void 0 : field.name });
  const validity = useValidityStateContext();
  const message = (feedback == null ? void 0 : feedback.message) instanceof ClerkElementsFieldError ? feedback.message.message : feedback == null ? void 0 : feedback.message;
  const codes = feedback == null ? void 0 : feedback.codes;
  const fieldState = { state: enrichFieldState(validity, state), message, codes };
  return children(fieldState);
}
FieldState.displayName = DISPLAY_NAME3;

// src/react/common/form/global-error.tsx
var import_react_slot2 = require("@radix-ui/react-slot");
var React10 = __toESM(require("react"));
var import_jsx_runtime4 = require("react/jsx-runtime");
var DISPLAY_NAME4 = "ClerkElementsGlobalError";
var GlobalError = React10.forwardRef(
  ({ asChild = false, children, code, ...rest }, forwardedRef) => {
    const { errors } = useGlobalErrors();
    const error = errors == null ? void 0 : errors[0];
    if (!error || code && error.code !== code) {
      return null;
    }
    const Comp = asChild ? import_react_slot2.Slot : "div";
    const child = typeof children === "function" ? children(error) : children;
    if (isReactFragment(child)) {
      throw new ClerkElementsRuntimeError("<GlobalError /> cannot render a Fragment as a child.");
    }
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      Comp,
      {
        role: "alert",
        ...rest,
        ref: forwardedRef,
        children: child || error.message
      }
    );
  }
);
GlobalError.displayName = DISPLAY_NAME4;

// src/react/common/form/input.tsx
var import_logger = require("@clerk/shared/logger");
var import_react4 = require("@clerk/shared/react");
var import_telemetry = require("@clerk/shared/telemetry");
var React12 = __toESM(require("react"));

// src/react/utils/create-context-from-actor-ref.ts
var import_react3 = require("@xstate/react");
var React11 = __toESM(require("react"));
function createContextFromActorRef(displayName) {
  const ReactContext = React11.createContext(null);
  const OriginalProvider = ReactContext.Provider;
  function Provider({ children, actorRef }) {
    return React11.createElement(
      OriginalProvider,
      {
        value: actorRef
      },
      children
    );
  }
  Provider.displayName = displayName;
  function useContext5(allowMissingActor = false) {
    const actorRef = React11.useContext(ReactContext);
    if (!allowMissingActor && !actorRef) {
      throw new Error(
        `You used a hook from "${Provider.displayName}" but it's not inside a <${Provider.displayName}.Provider> component.`
      );
    }
    return actorRef;
  }
  function useSelector3(selector, compare) {
    const actor = useContext5();
    return (0, import_react3.useSelector)(actor, selector, compare);
  }
  return {
    Provider,
    useActorRef: useContext5,
    useSelector: useSelector3
  };
}

// src/react/sign-in/context/router.context.ts
var SignInRouterCtx = createContextFromActorRef("SignInRouterCtx");
var useSignInPasskeyAutofill = () => SignInRouterCtx.useSelector((state) => state.context.webAuthnAutofillSupport);

// src/react/common/form/input.tsx
var import_jsx_runtime5 = require("react/jsx-runtime");
var DISPLAY_NAME5 = "ClerkElementsInput";
var DISPLAY_NAME_PASSKEYS_AUTOFILL = "ClerkElementsInputWithPasskeyAutofill";
var Input = React12.forwardRef(
  (props, forwardedRef) => {
    var _a, _b, _c;
    const clerk = (0, import_react4.useClerk)();
    const field = useInput(props);
    const hasPasskeyAutofillProp = Boolean((_a = field.props.autoComplete) == null ? void 0 : _a.includes("webauthn"));
    const allowedTypeForPasskey = ["text", "email", "tel"].includes(field.props.type);
    const signInRouterRef = SignInRouterCtx.useActorRef(true);
    (_c = clerk.telemetry) == null ? void 0 : _c.record(
      (0, import_telemetry.eventComponentMounted)("Elements_Input", {
        type: (_b = props.type) != null ? _b : false,
        // @ts-expect-error - Depending on type the props can be different
        render: Boolean(props == null ? void 0 : props.render),
        // @ts-expect-error - Depending on type the props can be different
        asChild: Boolean(props == null ? void 0 : props.asChild),
        // @ts-expect-error - Depending on type the props can be different
        validatePassword: Boolean(props == null ? void 0 : props.validatePassword)
      })
    );
    if (signInRouterRef && hasPasskeyAutofillProp && allowedTypeForPasskey) {
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        InputWithPasskeyAutofill,
        {
          ref: forwardedRef,
          ...props
        }
      );
    }
    if (hasPasskeyAutofillProp && !allowedTypeForPasskey) {
      import_logger.logger.warnOnce(
        `<Input autoComplete="webauthn"> can only be used with <Input type="text"> or <Input type="email">`
      );
    } else if (hasPasskeyAutofillProp) {
      import_logger.logger.warnOnce(
        `<Input autoComplete="webauthn"> can only be used inside <SignIn> in order to trigger a sign-in attempt, otherwise it will be ignored.`
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      field.Element,
      {
        ref: forwardedRef,
        ...field.props
      }
    );
  }
);
Input.displayName = DISPLAY_NAME5;
var InputWithPasskeyAutofill = React12.forwardRef(
  (props, forwardedRef) => {
    const signInRouterRef = SignInRouterCtx.useActorRef(true);
    const passkeyAutofillSupported = useSignInPasskeyAutofill();
    React12.useEffect(() => {
      if (passkeyAutofillSupported) {
        signInRouterRef == null ? void 0 : signInRouterRef.send({ type: "AUTHENTICATE.PASSKEY.AUTOFILL" });
      }
    }, [passkeyAutofillSupported, signInRouterRef]);
    const field = useInput(props);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      field.Element,
      {
        ref: forwardedRef,
        ...field.props
      }
    );
  }
);
InputWithPasskeyAutofill.displayName = DISPLAY_NAME_PASSKEYS_AUTOFILL;

// src/react/common/form/label.tsx
var import_react_form5 = require("@radix-ui/react-form");
var DISPLAY_NAME6 = "ClerkElementsLabel";
var Label = import_react_form5.Label;
Label.displayName = DISPLAY_NAME6;

// src/react/common/form/submit.tsx
var import_react_form6 = require("@radix-ui/react-form");
var DISPLAY_NAME7 = "ClerkElementsSubmit";
var Submit = import_react_form6.Submit;
Submit.displayName = DISPLAY_NAME7;

// src/react/common/connections.tsx
var import_react_slot3 = require("@radix-ui/react-slot");
var import_react7 = require("react");

// src/react/hooks/use-third-party-provider.hook.ts
var import_react5 = require("@clerk/shared/react");
var import_react6 = require("react");

// src/utils/third-party-strategies.ts
var import_types3 = require("@clerk/types");

// src/utils/clerk-js.ts
var fromEntries = (iterable) => {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
};
function iconImageUrl(id) {
  return `https://img.clerk.com/static/${id}.svg`;
}

// src/utils/third-party-strategies.ts
var oauthStrategies = import_types3.OAUTH_PROVIDERS.map((p) => p.strategy);
var providerToDisplayData = fromEntries(
  [...import_types3.OAUTH_PROVIDERS, ...import_types3.WEB3_PROVIDERS].map((p) => {
    return [p.provider, { iconUrl: iconImageUrl(p.provider), name: p.name, strategy: p.strategy }];
  })
);
var strategyToDisplayData = fromEntries(
  [...import_types3.OAUTH_PROVIDERS, ...import_types3.WEB3_PROVIDERS].map((p) => {
    return [p.strategy, { iconUrl: iconImageUrl(p.provider), id: p.provider, name: p.name }];
  })
);
function isSamlStrategy(strategy) {
  return strategy === "saml";
}
function isWeb3Strategy(strategy, available) {
  return available.includes(strategy.startsWith("web3_") ? strategy : `web3_${strategy}_signature`);
}
function isAuthenticatableOauthStrategy(strategy, available) {
  return available.includes(strategy.startsWith("oauth_") ? strategy : `oauth_${strategy}`);
}
var emptyThirdPartyProviders = {
  authenticatableOauthStrategies: [],
  providerToDisplayData: {},
  strategies: [],
  strategyToDisplayData: {},
  web3Strategies: []
};
var getEnabledThirdPartyProviders = (environment) => {
  if (!(environment == null ? void 0 : environment.userSettings)) {
    return emptyThirdPartyProviders;
  }
  const { socialProviderStrategies, web3FirstFactors, authenticatableSocialStrategies } = environment.userSettings;
  const knownSocialProviderStrategies = socialProviderStrategies.filter((s) => oauthStrategies.includes(s));
  const knownAuthenticatableSocialStrategies = authenticatableSocialStrategies.filter((s) => oauthStrategies.includes(s));
  return {
    authenticatableOauthStrategies: [...knownAuthenticatableSocialStrategies],
    providerToDisplayData,
    strategies: [...knownSocialProviderStrategies, ...web3FirstFactors],
    strategyToDisplayData,
    web3Strategies: web3FirstFactors
  };
};

// src/react/hooks/use-third-party-provider.hook.ts
var useIsProviderEnabled = (provider) => {
  var _a, _b;
  const clerk = (0, import_react5.useClerk)();
  if (!clerk.loaded) {
    return null;
  }
  if (provider === "saml") {
    return (_b = (_a = clerk.__unstable__environment) == null ? void 0 : _a.userSettings.saml.enabled) != null ? _b : false;
  }
  const data = getEnabledThirdPartyProviders(clerk.__unstable__environment);
  return isAuthenticatableOauthStrategy(provider, data.authenticatableOauthStrategies) || isWeb3Strategy(provider, data.web3Strategies);
};
var useThirdPartyProvider = (ref, provider) => {
  const isProviderEnabled = useIsProviderEnabled(provider);
  const isSaml = isSamlStrategy(provider);
  const details = isSaml ? {
    name: "SAML",
    strategy: "saml"
  } : providerToDisplayData[provider];
  const authenticate = (0, import_react6.useCallback)(
    (event) => {
      if (!isProviderEnabled) {
        return;
      }
      event.preventDefault();
      if (isSaml) {
        return ref.send({ type: "AUTHENTICATE.SAML" });
      }
      if (provider === "metamask") {
        return ref.send({ type: "AUTHENTICATE.WEB3", strategy: "web3_metamask_signature" });
      }
      if (provider === "coinbase_wallet") {
        return ref.send({ type: "AUTHENTICATE.WEB3", strategy: "web3_coinbase_wallet_signature" });
      }
      return ref.send({ type: "AUTHENTICATE.OAUTH", strategy: `oauth_${provider}` });
    },
    [provider, isProviderEnabled, isSaml, ref]
  );
  if (isProviderEnabled === false) {
    const dashboardPath = `https://dashboard.clerk.com/last-active?path=/user-authentication/${provider === "metamask" ? "web3" : "social-connections"}`;
    throw new ClerkElementsRuntimeError(
      `You have used <Connection name="${provider}"> which isn't enabled for your project. Enable ${details.name} in your Clerk dashboard: ${dashboardPath}`
    );
  }
  return {
    events: {
      authenticate
    },
    ...details
  };
};

// src/react/sign-up/context/router.context.ts
var SignUpRouterCtx = createContextFromActorRef("SignUpRouterCtx");

// src/react/common/connections.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var ConnectionContext = (0, import_react7.createContext)(null);
var useConnectionContext = () => {
  const ctx = (0, import_react7.useContext)(ConnectionContext);
  if (!ctx) {
    throw new Error("useConnectionContext must be used within <Clerk.Connection>");
  }
  return ctx;
};
function Connection({ asChild, name, ...rest }) {
  const signInRef = SignInRouterCtx.useActorRef(true);
  const signUpRef = SignUpRouterCtx.useActorRef(true);
  const provider = useThirdPartyProvider(signInRef || signUpRef, name);
  if (!provider) {
    return null;
  }
  const Comp = asChild ? import_react_slot3.Slot : "button";
  const defaultProps = asChild ? {} : { type: "button" };
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ConnectionContext.Provider, { value: provider, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    Comp,
    {
      onClick: provider.events.authenticate,
      ...defaultProps,
      ...rest
    }
  ) });
}
function Icon({ asChild, ...rest }) {
  const { iconUrl, name } = useConnectionContext();
  const Comp = asChild ? import_react_slot3.Slot : "img";
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    Comp,
    {
      alt: `${name} logo`,
      src: iconUrl,
      ...rest
    }
  );
}

// src/react/common/loading.tsx
var import_react11 = require("@clerk/shared/react");
var import_telemetry4 = require("@clerk/shared/telemetry");
var import_react12 = require("@xstate/react");

// src/react/hooks/use-loading.hook.ts
var import_react8 = require("@xstate/react");
var selectLoading = (snapshot) => {
  var _a;
  return (_a = snapshot == null ? void 0 : snapshot.context) == null ? void 0 : _a.loading;
};
var compareLoadingValue = (prev, next) => (prev == null ? void 0 : prev.isLoading) === (next == null ? void 0 : next.isLoading);
function useLoading(actor) {
  const loadingCtx = (0, import_react8.useSelector)(actor, selectLoading, compareLoadingValue);
  if (!loadingCtx) {
    return [false, { step: void 0, strategy: void 0, action: void 0 }];
  }
  return [loadingCtx.isLoading, { step: loadingCtx.step, strategy: loadingCtx.strategy, action: loadingCtx.action }];
}

// src/react/sign-in/step.tsx
var import_react9 = require("@clerk/shared/react");
var import_telemetry2 = require("@clerk/shared/telemetry");
var import_jsx_runtime7 = require("react/jsx-runtime");
var SIGN_IN_STEPS = {
  start: "start",
  verifications: "verifications",
  "choose-strategy": "choose-strategy",
  "choose-session": "choose-session",
  "forgot-password": "forgot-password",
  "reset-password": "reset-password"
};

// src/react/sign-up/step.tsx
var import_react10 = require("@clerk/shared/react");
var import_telemetry3 = require("@clerk/shared/telemetry");
var import_jsx_runtime8 = require("react/jsx-runtime");
var SIGN_UP_STEPS = {
  start: "start",
  continue: "continue",
  verifications: "verifications"
};

// src/react/utils/map-scope-to-strategy.ts
function isProviderStrategyScope(value) {
  return value.startsWith("provider:");
}
function mapScopeToStrategy(scope) {
  if (scope === "provider:metamask") {
    return "web3_metamask_signature";
  }
  if (scope === "provider:coinbase_wallet") {
    return "web3_coinbase_wallet_signature";
  }
  if (scope === "provider:saml") {
    return "saml";
  }
  const scopeWithoutPrefix = scope.replace("provider:", "");
  return `oauth_${scopeWithoutPrefix}`;
}

// src/react/common/loading.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
function isSignInScope(scope) {
  if (!scope) {
    return true;
  }
  if (scope.startsWith("step:")) {
    return Object.prototype.hasOwnProperty.call(SIGN_IN_STEPS, scope.replace("step:", ""));
  }
  return true;
}
function isSignUpScope(scope) {
  if (!scope) {
    return true;
  }
  if (scope.startsWith("step:")) {
    return Object.prototype.hasOwnProperty.call(SIGN_UP_STEPS, scope.replace("step:", ""));
  }
  return true;
}
function Loading({ children, scope }) {
  var _a;
  const clerk = (0, import_react11.useClerk)();
  (_a = clerk.telemetry) == null ? void 0 : _a.record((0, import_telemetry4.eventComponentMounted)("Elements_Loading", { scope: scope != null ? scope : false }));
  const signInRouterRef = SignInRouterCtx.useActorRef(true);
  const signUpRouterRef = SignUpRouterCtx.useActorRef(true);
  if (!signInRouterRef && !signUpRouterRef) {
    throw new ClerkElementsRuntimeError(`<Loading> must be used within a <SignIn> or <SignUp> component.`);
  }
  if (signInRouterRef) {
    if (isSignInScope(scope)) {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        SignInLoading,
        {
          scope,
          routerRef: signInRouterRef,
          children
        }
      );
    } else {
      throw new ClerkElementsRuntimeError(`Invalid scope "${scope}" used for <Loading> inside <SignIn>.`);
    }
  }
  if (signUpRouterRef) {
    if (isSignUpScope(scope)) {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        SignUpLoading,
        {
          scope,
          routerRef: signUpRouterRef,
          children
        }
      );
    } else {
      throw new ClerkElementsRuntimeError(`Invalid scope "${scope}" used for <Loading> inside <SignUp>.`);
    }
  }
  throw new ClerkElementsRuntimeError("Invalid state for <Loading>. Please open an issue.");
}
function SignInLoading({ children, scope, routerRef }) {
  const [isLoading, { step: loadingStep, strategy, action }] = useLoading(routerRef);
  const tags = (0, import_react12.useSelector)(routerRef, (s) => s.tags);
  const isStepLoading = (step) => isLoading && loadingStep === step;
  const isInferredStepLoading = (step) => tags.has(`step:${step}`) && isStepLoading(step);
  let loadingResult = false;
  if (scope === "global") {
    loadingResult = isLoading;
  } else if (scope && isProviderStrategyScope(scope)) {
    loadingResult = isLoading && loadingStep === void 0 && strategy === mapScopeToStrategy(scope);
  } else if (scope) {
    loadingResult = isStepLoading(scope.replace("step:", "")) || scope === action;
  } else {
    loadingResult = isInferredStepLoading("start") || isInferredStepLoading("verifications") || isInferredStepLoading("choose-strategy") || isInferredStepLoading("forgot-password") || isInferredStepLoading("reset-password");
  }
  return children(loadingResult);
}
function SignUpLoading({ children, scope, routerRef }) {
  const [isLoading, { step: loadingStep, strategy, action }] = useLoading(routerRef);
  const tags = (0, import_react12.useSelector)(routerRef, (s) => s.tags);
  const isStepLoading = (step) => isLoading && loadingStep === step;
  const isInferredStepLoading = (step) => tags.has(`step:${step}`) && isStepLoading(step);
  let loadingResult = false;
  if (scope === "global") {
    loadingResult = isLoading;
  } else if (scope && isProviderStrategyScope(scope)) {
    loadingResult = isLoading && loadingStep === void 0 && strategy === mapScopeToStrategy(scope);
  } else if (scope) {
    loadingResult = isStepLoading(scope.replace("step:", "")) || scope === action;
  } else {
    loadingResult = isInferredStepLoading("start") || isInferredStepLoading("continue") || isInferredStepLoading("verifications");
  }
  return children(loadingResult);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Connection,
  Field,
  FieldError,
  FieldState,
  GlobalError,
  Icon,
  Input,
  Label,
  Loading,
  Submit
});
//# sourceMappingURL=index.js.map