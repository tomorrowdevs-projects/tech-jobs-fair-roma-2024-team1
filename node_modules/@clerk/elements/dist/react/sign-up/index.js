"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/react/sign-up/index.ts
var sign_up_exports = {};
__export(sign_up_exports, {
  Action: () => SignUpAction,
  Captcha: () => SignUpCaptcha,
  Root: () => SignUpRoot,
  SignUp: () => SignUpRoot,
  Step: () => SignUpStep,
  Strategy: () => SignUpStrategy
});
module.exports = __toCommonJS(sign_up_exports);
var import_client_only2 = require("client-only");

// src/react/sign-up/root.tsx
var import_react6 = require("@clerk/shared/react");
var import_router5 = require("@clerk/shared/router");
var import_telemetry = require("@clerk/shared/telemetry");
var import_react7 = require("@xstate/react");
var import_react8 = require("react");
var import_xstate8 = require("xstate");

// src/utils/safe-access.ts
function safeAccess(fn, fallback) {
  try {
    return fn();
  } catch (e) {
    return fallback;
  }
}

// src/internals/constants/index.ts
var SSO_CALLBACK_PATH_ROUTE = "/sso-callback";
var MAGIC_LINK_VERIFY_PATH_ROUTE = "/verify";
var SIGN_IN_DEFAULT_BASE_PATH = safeAccess(
  () => {
    var _a;
    return (_a = process.env.CLERK_SIGN_IN_URL) != null ? _a : process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL;
  },
  "/sign-in"
);
var SIGN_UP_DEFAULT_BASE_PATH = safeAccess(
  () => {
    var _a;
    return (_a = process.env.CLERK_SIGN_UP_URL) != null ? _a : process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL;
  },
  "/sign-up"
);
var NEXT_WINDOW_HISTORY_SUPPORT_VERSION = "14.1.0";
var SEARCH_PARAMS = {
  createdSession: "__clerk_created_session",
  handshake: "__clerk_handshake",
  help: "__clerk_help",
  invitationToken: "__clerk_invitation_token",
  modalState: "__clerk_modal_state",
  satelliteUrl: "__clerk_satellite_url",
  status: "__clerk_status",
  synced: "__clerk_synced",
  ticket: "__clerk_ticket",
  transfer: "__clerk_transfer"
};
var RESENDABLE_COUNTDOWN_DEFAULT = 60;
var CAPTCHA_ELEMENT_ID = "clerk-captcha";
var ERROR_CODES = {
  FORM_IDENTIFIER_NOT_FOUND: "form_identifier_not_found",
  FORM_PASSWORD_INCORRECT: "form_password_incorrect",
  INVALID_STRATEGY_FOR_USER: "strategy_for_user_invalid",
  NOT_ALLOWED_TO_SIGN_UP: "not_allowed_to_sign_up",
  OAUTH_ACCESS_DENIED: "oauth_access_denied",
  OAUTH_EMAIL_DOMAIN_RESERVED_BY_SAML: "oauth_email_domain_reserved_by_saml",
  NOT_ALLOWED_ACCESS: "not_allowed_access",
  SAML_USER_ATTRIBUTE_MISSING: "saml_user_attribute_missing",
  USER_LOCKED: "user_locked"
};
var ROUTING = {
  path: "path",
  virtual: "virtual"
};

// src/internals/machines/form/form.context.ts
var import_react = require("@xstate/react");

// src/internals/machines/form/form.machine.ts
var import_error = require("@clerk/shared/error");
var import_underscore = require("@clerk/shared/underscore");
var import_xstate = require("xstate");

// src/internals/errors/index.ts
var ClerkElementsErrorBase = class extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.clerkError = true;
    this.clerkElementsError = true;
    this.name = "ClerkElementsError";
    this.rawMessage = message;
  }
  toString() {
    return `[${this.name}]
Code: ${this.code}
Message: ${this.message}`;
  }
};
var ClerkElementsError = class _ClerkElementsError extends ClerkElementsErrorBase {
  static fromAPIError(error) {
    return new _ClerkElementsError(
      error.code.toString(),
      // @ts-expect-error - Expected that longMessage isn't a property of MetamaskError
      error.longMessage || error.message
    );
  }
  constructor(code, message) {
    super(code, message);
    this.name = "ClerkElementsError";
  }
};
var ClerkElementsRuntimeError = class extends ClerkElementsErrorBase {
  constructor(message) {
    super("elements_runtime_error", message);
    this.name = "ClerkElementsRuntimeError";
  }
};
var ClerkElementsFieldError = class _ClerkElementsFieldError extends ClerkElementsErrorBase {
  constructor(code, message) {
    super(code, message);
    this.matchFn = () => true;
    this.name = "ClerkElementsFieldError";
  }
  static fromAPIError(error) {
    return new _ClerkElementsFieldError(error.code, error.longMessage || error.message);
  }
  get validityState() {
    return this.code;
  }
  get forceMatch() {
    return true;
  }
};

// src/internals/machines/form/form.machine.ts
var FormMachine = (0, import_xstate.setup)({
  actions: {
    setGlobalErrors: (0, import_xstate.assign)({
      errors: (_, params) => [...params.errors]
    }),
    setFieldFeedback: (0, import_xstate.assign)({
      fields: ({ context }, params) => {
        if (!params.name) {
          throw new Error("Field name is required");
        }
        if (context.fields.has(params.name)) {
          context.fields.get(params.name).feedback = params.feedback;
        }
        return context.fields;
      }
    })
  },
  types: {}
}).createMachine({
  id: "Form",
  context: () => ({
    defaultValues: /* @__PURE__ */ new Map(),
    errors: [],
    fields: /* @__PURE__ */ new Map(),
    progressive: false
  }),
  on: {
    "ERRORS.SET": {
      actions: (0, import_xstate.enqueueActions)(({ enqueue, event }) => {
        var _a, _b, _c;
        const isClerkAPIError = (err) => "meta" in err;
        if ((0, import_error.isKnownError)(event.error)) {
          const fields = {};
          const globalErrors = [];
          const errors = (0, import_error.isClerkAPIResponseError)(event.error) ? (_a = event.error) == null ? void 0 : _a.errors : [event.error];
          for (const error of errors) {
            const name = isClerkAPIError(error) ? (0, import_underscore.snakeToCamel)((_b = error.meta) == null ? void 0 : _b.paramName) : null;
            if (!name || (0, import_error.isMetamaskError)(error)) {
              globalErrors.push(ClerkElementsError.fromAPIError(error));
              continue;
            }
            if (!fields[name]) {
              fields[name] = [];
            }
            (_c = fields[name]) == null ? void 0 : _c.push(ClerkElementsFieldError.fromAPIError(error));
          }
          enqueue({
            type: "setGlobalErrors",
            params: {
              errors: globalErrors
            }
          });
          for (const field in fields) {
            enqueue({
              type: "setFieldFeedback",
              params: {
                name: field,
                feedback: {
                  type: "error",
                  message: fields[field][0]
                }
              }
            });
          }
        }
      })
    },
    "ERRORS.CLEAR": {
      actions: (0, import_xstate.assign)({
        errors: () => []
      })
    },
    "FIELD.ADD": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          event.field.value = event.field.value || context.defaultValues.get(event.field.name) || void 0;
          context.fields.set(event.field.name, event.field);
          return context.fields;
        }
      })
    },
    "FIELD.UPDATE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.checked = event.field.checked;
            field.disabled = event.field.disabled || false;
            field.value = event.field.value;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.DISABLE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.disabled = true;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.ENABLE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.disabled = false;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.REMOVE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          context.fields.delete(event.field.name);
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.SET": {
      actions: [
        {
          type: "setFieldFeedback",
          params: ({ event }) => event.field
        }
      ]
    },
    "FIELD.FEEDBACK.CLEAR": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          if (context.fields.has(event.field.name)) {
            context.fields.get(event.field.name).feedback = void 0;
          }
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.CLEAR.ALL": {
      actions: (0, import_xstate.assign)({
        fields: ({ context }) => {
          context.fields.forEach((field) => {
            field.feedback = void 0;
          });
          return context.fields;
        }
      })
    },
    MARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)(({ event }) => {
        const missing = new Set(event.missing);
        return {
          defaultValues: event.defaultValues,
          hidden: /* @__PURE__ */ new Set([...event.required.filter((f) => !missing.has(f)), ...event.optional]),
          missing,
          optional: new Set(event.optional),
          progressive: true,
          required: new Set(event.required)
        };
      })
    },
    UNMARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)({
        defaultValues: /* @__PURE__ */ new Map(),
        hidden: void 0,
        missing: void 0,
        optional: void 0,
        progressive: false,
        required: void 0
      })
    },
    PREFILL_DEFAULT_VALUES: {
      actions: (0, import_xstate.assign)(({ event }) => {
        return {
          defaultValues: event.defaultValues
        };
      })
    }
  }
});

// src/internals/utils/inspector/index.ts
var inspect;
if (false) {
  inspect = (_a = getBrowserInspector()) != null ? _a : getConsoleInspector();
}

// src/internals/machines/form/form.context.ts
var FormMachineContext = (0, import_react.createActorContext)(FormMachine, { inspect });
var FormStoreProvider = FormMachineContext.Provider;
var useFormStore = FormMachineContext.useActorRef;
var useFormSelector = FormMachineContext.useSelector;
var globalErrorsSelector = (state) => state.context.errors;

// src/internals/machines/sign-up/continue.machine.ts
var import_underscore2 = require("@clerk/shared/underscore");
var import_xstate2 = require("xstate");

// src/internals/machines/shared/shared.actions.ts
function sendToLoading({ context, event }) {
  let step;
  let strategy;
  let action;
  if (event.type.startsWith("xstate.done.") || event.type.startsWith("xstate.error.")) {
    return context.parent.send({
      type: "LOADING",
      isLoading: false,
      step: void 0,
      strategy: void 0
    });
  }
  if (context.loadingStep === "strategy") {
    step = void 0;
    if (event.type === "REDIRECT") {
      strategy = event.params.strategy;
    }
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy
    });
  } else if (context.loadingStep === "continue") {
    step = "continue";
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  } else if (context.loadingStep === "reset-password") {
    step = "reset-password";
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  } else if (context.loadingStep === "start") {
    step = "start";
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  } else {
    step = context.loadingStep;
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  }
}

// src/internals/machines/sign-up/utils/fields-to-params.ts
var SignUpAdditionalKeys = ["firstName", "lastName", "emailAddress", "username", "password", "phoneNumber"];
var signUpKeys = new Set(SignUpAdditionalKeys);
function isSignUpParam(key) {
  return signUpKeys.has(key);
}
function fieldsToSignUpParams(fields) {
  const params = {};
  fields.forEach(({ value }, key) => {
    if (isSignUpParam(key) && value !== void 0) {
      params[key] = value;
    }
  });
  return params;
}

// src/internals/machines/utils/assert.ts
function assertActorEventError(event) {
  if ("error" in event === false) {
    throw new Error(`Expected an error event, got "${event.type}"`);
  }
}

// src/internals/machines/sign-up/continue.machine.ts
var SignUpContinueMachineId = "SignUpContinue";
var SignUpContinueMachine = (0, import_xstate2.setup)({
  actors: {
    attempt: (0, import_xstate2.fromPromise)(
      ({ input: { fields, parent } }) => {
        const params = fieldsToSignUpParams(fields);
        return parent.getSnapshot().context.clerk.client.signUp.update(params);
      }
    )
  },
  actions: {
    setFormErrors: ({ context, event }) => {
      assertActorEventError(event);
      context.formRef.send({
        type: "ERRORS.SET",
        error: event.error
      });
    },
    markFormAsProgressive: ({ context }) => {
      const signUp = context.parent.getSnapshot().context.clerk.client.signUp;
      const missing = signUp.missingFields.map(import_underscore2.snakeToCamel);
      const optional = signUp.optionalFields.map(import_underscore2.snakeToCamel);
      const required = signUp.requiredFields.map(import_underscore2.snakeToCamel);
      const progressiveFieldValues = /* @__PURE__ */ new Map();
      for (const key of required.concat(optional)) {
        if (key in signUp) {
          progressiveFieldValues.set(key, signUp[key]);
        }
      }
      context.formRef.send({
        type: "MARK_AS_PROGRESSIVE",
        missing,
        optional,
        required,
        defaultValues: progressiveFieldValues
      });
    },
    unmarkFormAsProgressive: ({ context }) => context.formRef.send({ type: "UNMARK_AS_PROGRESSIVE" }),
    sendToNext: ({ context, event }) => context.parent.send({ type: "NEXT", resource: event.output }),
    sendToLoading
  },
  types: {}
}).createMachine({
  id: SignUpContinueMachineId,
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    formRef: input.formRef,
    parent: input.parent,
    loadingStep: "continue"
  }),
  entry: "markFormAsProgressive",
  onDone: {
    actions: "unmarkFormAsProgressive"
  },
  initial: "Pending",
  states: {
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          target: "Attempting",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attempt",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-up/router.machine.ts
var import_url = require("@clerk/shared/url");
var import_xstate7 = require("xstate");

// src/internals/machines/third-party/third-party.actors.ts
var import_xstate3 = require("xstate");

// src/internals/machines/utils/clerkjs.ts
function isClerkJSEvent(eventObj, event) {
  return Object.values(eventObj).includes(event);
}
var ClerkJSNavigationEvent = {
  complete: "CLERKJS.NAVIGATE.COMPLETE",
  signUp: "CLERKJS.NAVIGATE.SIGN_UP",
  continue: "CLERKJS.NAVIGATE.CONTINUE",
  generic: "CLERKJS.NAVIGATE.GENERIC",
  resetPassword: "CLERKJS.NAVIGATE.RESET_PASSWORD",
  signIn: "CLERKJS.NAVIGATE.SIGN_IN",
  verification: "CLERKJS.NAVIGATE.VERIFICATION"
};
function isClerkJSNavigationEvent(event) {
  return isClerkJSEvent(ClerkJSNavigationEvent, event);
}

// src/internals/machines/third-party/third-party.actors.ts
var redirect = (0, import_xstate3.fromPromise)(
  async ({ input: { flow, params, parent } }) => {
    const clerk = parent.getSnapshot().context.clerk;
    return clerk.client[flow].authenticateWithRedirect({
      redirectUrl: clerk.buildUrlWithAuth(params.redirectUrl || "/"),
      redirectUrlComplete: clerk.buildUrlWithAuth(params.redirectUrlComplete || "/"),
      ...params
    });
  }
);
var handleRedirectCallback = (0, import_xstate3.fromCallback)(
  ({ sendBack, input: parent }) => {
    var _a;
    const clerk = parent.getSnapshot().context.clerk;
    const displayConfig = (_a = clerk.__unstable__environment) == null ? void 0 : _a.displayConfig;
    const customNavigate = (toEvt) => {
      const to = toEvt.split("/").slice(-1)[0];
      if (isClerkJSNavigationEvent(to)) {
        sendBack({ type: to });
      } else if (to === (displayConfig == null ? void 0 : displayConfig.signInUrl)) {
        sendBack({ type: ClerkJSNavigationEvent.signIn });
      } else if (to === (displayConfig == null ? void 0 : displayConfig.signUpUrl)) {
        sendBack({ type: ClerkJSNavigationEvent.signUp });
      } else {
        sendBack({ type: "FAILURE", error: new ClerkElementsRuntimeError(`Unknown navigation event: ${to}`) });
      }
      return Promise.resolve();
    };
    const loadedClerk = clerk.clerkjs;
    void loadedClerk.handleRedirectCallback(
      {
        signInForceRedirectUrl: ClerkJSNavigationEvent.complete,
        signInFallbackRedirectUrl: ClerkJSNavigationEvent.complete,
        signUpForceRedirectUrl: ClerkJSNavigationEvent.signUp,
        signUpFallbackRedirectUrl: ClerkJSNavigationEvent.signUp,
        continueSignUpUrl: ClerkJSNavigationEvent.continue,
        firstFactorUrl: ClerkJSNavigationEvent.signIn,
        resetPasswordUrl: ClerkJSNavigationEvent.resetPassword,
        secondFactorUrl: ClerkJSNavigationEvent.signIn,
        verifyEmailAddressUrl: ClerkJSNavigationEvent.verification,
        verifyPhoneNumberUrl: ClerkJSNavigationEvent.verification,
        signUpUrl: ClerkJSNavigationEvent.signUp,
        signInUrl: ClerkJSNavigationEvent.signIn
      },
      customNavigate
    );
    return () => void 0;
  }
);

// src/internals/machines/third-party/third-party.machine.ts
var import_xstate4 = require("xstate");
var ThirdPartyMachineId = "ThirdParty";
var ThirdPartyMachine = (0, import_xstate4.setup)({
  actors: {
    handleRedirectCallback,
    redirect
  },
  actions: {
    logError: (0, import_xstate4.log)(({ event }) => `Error: ${event.type}`),
    assignActiveStrategy: (0, import_xstate4.assign)({
      activeStrategy: ({ event }) => {
        (0, import_xstate4.assertEvent)(event, "REDIRECT");
        return event.params.strategy;
      }
    }),
    unassignActiveStrategy: (0, import_xstate4.assign)({
      activeStrategy: null
    }),
    sendToNext: ({ context }) => context.parent.send({ type: "NEXT" }),
    sendToLoading,
    setFormErrors: (0, import_xstate4.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isExampleMode: ({ context }) => Boolean(context.parent.getSnapshot().context.exampleMode)
  },
  types: {}
}).createMachine({
  id: ThirdPartyMachineId,
  context: ({ input }) => ({
    activeStrategy: null,
    basePath: input.basePath,
    formRef: input.formRef,
    flow: input.flow,
    parent: input.parent,
    loadingStep: "strategy"
  }),
  initial: "Idle",
  states: {
    Idle: {
      description: "Sets third-party providers if not already set, and waits for a redirect or callback event",
      on: {
        CALLBACK: "HandlingCallback",
        REDIRECT: {
          guard: (0, import_xstate4.not)("isExampleMode"),
          target: "Redirecting",
          reenter: true
        }
      }
    },
    Redirecting: {
      description: "Redirects to the third-party provider for authentication",
      tags: ["state:redirect", "state:loading"],
      entry: ["assignActiveStrategy", "sendToLoading"],
      exit: ["unassignActiveStrategy", "sendToLoading"],
      invoke: {
        id: "redirect",
        src: "redirect",
        input: ({ context, event }) => {
          (0, import_xstate4.assertEvent)(event, "REDIRECT");
          return {
            basePath: context.basePath,
            flow: context.flow,
            params: event.params,
            parent: context.parent
          };
        },
        onError: {
          actions: "setFormErrors",
          target: "Idle"
        }
      }
    },
    HandlingCallback: {
      description: "Handles the callback from the third-party provider",
      tags: ["state:callback", "state:loading"],
      invoke: {
        id: "handleRedirectCallback",
        src: "handleRedirectCallback",
        input: ({ context }) => context.parent,
        onError: {
          actions: ["logError", "setFormErrors"],
          target: "Idle"
        }
      },
      on: {
        "CLERKJS.NAVIGATE.*": {
          actions: "sendToNext",
          target: "Idle"
        }
      }
    }
  }
});

// src/internals/machines/utils/next.ts
function shouldUseVirtualRouting() {
  if (typeof window === "undefined") {
    return false;
  }
  if (!window.next) {
    return false;
  }
  return window.next.version < NEXT_WINDOW_HISTORY_SUPPORT_VERSION;
}

// src/internals/machines/sign-up/start.machine.ts
var import_xstate5 = require("xstate");
var DISABLEABLE_FIELDS = ["emailAddress", "phoneNumber"];
var SignUpStartMachineId = "SignUpStart";
var PREFILL_FIELDS = ["firstName", "lastName", "emailAddress", "username", "phoneNumber"];
var SignUpStartMachine = (0, import_xstate5.setup)({
  actors: {
    attempt: (0, import_xstate5.fromPromise)(({ input: { fields, parent, params } }) => {
      const fieldParams = fieldsToSignUpParams(fields);
      return parent.getSnapshot().context.clerk.client.signUp.create({ ...fieldParams, ...params });
    }),
    attemptWeb3: (0, import_xstate5.fromPromise)(
      ({ input: { parent, strategy } }) => {
        if (strategy === "web3_metamask_signature") {
          return parent.getSnapshot().context.clerk.client.signUp.authenticateWithMetamask();
        }
        if (strategy === "web3_coinbase_wallet_signature") {
          return parent.getSnapshot().context.clerk.client.signUp.authenticateWithCoinbaseWallet();
        }
        throw new ClerkElementsRuntimeError(`Unsupported Web3 strategy: ${strategy}`);
      }
    ),
    thirdParty: ThirdPartyMachine
  },
  actions: {
    sendToNext: ({ context }) => context.parent.send({ type: "NEXT" }),
    sendToLoading,
    setFormDisabledTicketFields: (0, import_xstate5.enqueueActions)(({ context, enqueue }) => {
      if (!context.ticket) {
        return;
      }
      const currentFields = context.formRef.getSnapshot().context.fields;
      for (const name of DISABLEABLE_FIELDS) {
        if (currentFields.has(name)) {
          enqueue.sendTo(context.formRef, { type: "FIELD.DISABLE", field: { name } });
        }
      }
    }),
    setFormErrors: (0, import_xstate5.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    ),
    setDefaultFormValues: ({ context }) => {
      const signUp = context.parent.getSnapshot().context.clerk.client.signUp;
      const prefilledDefaultValues = /* @__PURE__ */ new Map();
      for (const key of PREFILL_FIELDS) {
        if (key in signUp) {
          prefilledDefaultValues.set(key, signUp[key]);
        }
      }
      context.formRef.send({
        type: "PREFILL_DEFAULT_VALUES",
        defaultValues: prefilledDefaultValues
      });
    }
  },
  guards: {
    hasTicket: ({ context }) => Boolean(context.ticket),
    isExampleMode: ({ context }) => Boolean(context.parent.getSnapshot().context.exampleMode)
  },
  types: {}
}).createMachine({
  id: SignUpStartMachineId,
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    formRef: input.formRef,
    parent: input.parent,
    loadingStep: "start",
    ticket: input.ticket
  }),
  entry: "setDefaultFormValues",
  initial: "Init",
  states: {
    Init: {
      description: "Handle ticket, if present; Else, default to Pending state. Per tickets, `Attempting` makes a `signUp.create` request allowing for an incomplete sign up to contain progressively filled fields on the Start step.",
      always: [
        {
          guard: "hasTicket",
          target: "Attempting"
        },
        {
          target: "Pending"
        }
      ]
    },
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          guard: (0, import_xstate5.not)("isExampleMode"),
          target: "Attempting",
          reenter: true
        },
        "AUTHENTICATE.WEB3": {
          guard: (0, import_xstate5.not)("isExampleMode"),
          target: "AttemptingWeb3",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attemptCreate",
        src: "attempt",
        input: ({ context }) => {
          const defaultParams = {
            fields: context.formRef.getSnapshot().context.fields,
            parent: context.parent
          };
          const params = context.ticket ? {
            strategy: "ticket",
            ticket: context.ticket
          } : {};
          return { ...defaultParams, params };
        },
        onDone: {
          actions: ["setFormDisabledTicketFields", "sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormDisabledTicketFields", "setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    },
    AttemptingWeb3: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attemptCreateWeb3",
        src: "attemptWeb3",
        input: ({ context, event }) => {
          (0, import_xstate5.assertEvent)(event, "AUTHENTICATE.WEB3");
          return {
            parent: context.parent,
            strategy: event.strategy
          };
        },
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-up/verification.machine.ts
var import_poller = require("@clerk/shared/poller");
var import_xstate6 = require("xstate");

// src/internals/machines/sign-up/verification.types.ts
var SignUpVerificationDelays = {
  emailLinkTimeout: 3e5,
  // 5 minutes
  resendableTimeout: 1e3
  // 1 second
};

// src/internals/machines/sign-up/verification.machine.ts
var SignUpVerificationMachineId = "SignUpVerification";
var shouldVerify = (field, strategy) => {
  const guards = [
    {
      type: "isFieldUnverified",
      params: {
        field
      }
    }
  ];
  if (strategy) {
    guards.push({
      type: "isStrategyEnabled",
      params: {
        attribute: field,
        strategy
      }
    });
  }
  return (0, import_xstate6.and)(guards);
};
var SignUpVerificationMachine = (0, import_xstate6.setup)({
  actors: {
    prepare: (0, import_xstate6.fromPromise)(({ input: { params, parent } }) => {
      const clerk = parent.getSnapshot().context.clerk;
      if (params.strategy === "email_link" && params.redirectUrl) {
        params.redirectUrl = clerk.buildUrlWithAuth(params.redirectUrl);
      }
      return clerk.client.signUp.prepareVerification(params);
    }),
    attempt: (0, import_xstate6.fromPromise)(
      async ({ input: { params, parent } }) => parent.getSnapshot().context.clerk.client.signUp.attemptVerification(params)
    ),
    attemptEmailLinkVerification: (0, import_xstate6.fromCallback)(
      ({ receive, sendBack, input: { parent } }) => {
        const { run, stop } = (0, import_poller.Poller)();
        const clerk = parent.getSnapshot().context.clerk;
        void run(
          async () => clerk.client.signUp.reload().then((resource) => {
            const signInStatus = resource.status;
            const verificationStatus = resource.verifications.emailAddress.status;
            if (signInStatus === "complete") {
              return sendBack({ type: "EMAIL_LINK.VERIFIED", resource });
            }
            switch (verificationStatus) {
              case "verified":
              case "transferable":
              case "expired": {
                sendBack({ type: `EMAIL_LINK.${verificationStatus.toUpperCase()}`, resource });
                break;
              }
              case "failed": {
                sendBack({
                  type: "EMAIL_LINK.FAILED",
                  error: new ClerkElementsError("email-link-verification-failed", "Email verification failed"),
                  resource
                });
                break;
              }
              default:
                return;
            }
            stop();
          }).catch((error) => {
            stop();
            new ClerkElementsRuntimeError(error);
          })
        );
        receive((event) => {
          if (event.type === "STOP") {
            stop();
          }
        });
        return () => stop();
      }
    )
  },
  actions: {
    resendableTick: (0, import_xstate6.assign)(({ context }) => ({
      resendable: context.resendableAfter === 1,
      resendableAfter: context.resendableAfter > 1 ? context.resendableAfter - 1 : context.resendableAfter
    })),
    resendableReset: (0, import_xstate6.assign)({
      resendable: false,
      resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT
    }),
    sendToLoading,
    setFormErrors: (0, import_xstate6.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isComplete: ({ context }) => context.resource.status === "complete",
    isFieldUnverified: ({ context, event }, { field }) => {
      let resource = context.resource;
      if ((event == null ? void 0 : event.type) === "NEXT" && event.resource) {
        resource = event.resource;
      }
      return resource.unverifiedFields.includes(field);
    },
    isResendable: ({ context }) => context.resendable || context.resendableAfter === 0,
    isStrategyEnabled: ({ context }, { attribute, strategy }) => {
      var _a;
      return Boolean((_a = context.attributes) == null ? void 0 : _a[attribute].verifications.includes(strategy));
    },
    shouldVerifyPhoneCode: shouldVerify("phone_number"),
    shouldVerifyEmailLink: shouldVerify("email_address", "email_link"),
    shouldVerifyEmailCode: shouldVerify("email_address", "email_code")
  },
  delays: SignUpVerificationDelays,
  types: {}
}).createMachine({
  id: SignUpVerificationMachineId,
  initial: "Init",
  context: ({ input }) => ({
    attributes: input.attributes,
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    loadingStep: "verifications",
    formRef: input.formRef,
    parent: input.parent,
    resendable: false,
    resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT,
    resource: input.resource
  }),
  on: {
    NEXT: [
      {
        guard: "isComplete",
        actions: (0, import_xstate6.sendParent)(({ event }) => ({ type: "NEXT", resource: event.resource }))
      },
      {
        description: "Validate via phone number",
        guard: "shouldVerifyPhoneCode",
        target: ".PhoneCode"
      },
      {
        description: "Validate via email link",
        guard: "shouldVerifyEmailLink",
        target: ".EmailLink"
      },
      {
        description: "Verify via email code",
        guard: "shouldVerifyEmailCode",
        target: ".EmailCode"
      },
      {
        actions: (0, import_xstate6.sendParent)(({ event }) => ({ type: "NEXT", resource: event.resource }))
      }
    ]
  },
  states: {
    Init: {
      always: [
        {
          description: "Validate via phone number",
          guard: "shouldVerifyPhoneCode",
          target: "PhoneCode"
        },
        {
          description: "Validate via email link",
          guard: "shouldVerifyEmailLink",
          target: "EmailLink"
        },
        {
          description: "Verify via email code",
          guard: "shouldVerifyEmailCode",
          target: "EmailCode"
        },
        {
          actions: (0, import_xstate6.sendParent)(({ context }) => ({ type: "NEXT", resource: context.resource }))
        }
      ]
    },
    EmailLink: {
      tags: ["verification:method:email", "verification:category:link", "verification:email_link"],
      initial: "Preparing",
      on: {
        RETRY: ".Preparing",
        "EMAIL_LINK.RESTART": {
          target: ".Attempting",
          reenter: true
        },
        "EMAIL_LINK.FAILED": {
          actions: [
            {
              type: "setFormErrors",
              params: ({ event }) => ({ error: event.error })
            },
            (0, import_xstate6.assign)({ resource: ({ event }) => event.resource })
          ],
          target: ".Pending"
        },
        "EMAIL_LINK.*": {
          actions: (0, import_xstate6.enqueueActions)(({ enqueue, event }) => {
            if (event.type === "EMAIL_LINK.RESTART") {
              return;
            }
            enqueue.assign({ resource: event.resource });
            enqueue.raise({ type: "NEXT", resource: event.resource });
          })
        }
      },
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          exit: "resendableReset",
          invoke: {
            id: "prepareEmailLinkVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "email_link",
                redirectUrl: `${context.basePath}${MAGIC_LINK_VERIFY_PATH_ROUTE}`
              }
            }),
            onDone: {
              target: "Attempting",
              actions: (0, import_xstate6.assign)({ resource: ({ event }) => event.output })
            },
            onError: {
              actions: "setFormErrors",
              target: "Pending"
            }
          }
        },
        Pending: {
          description: "Placeholder for allowing resending of email link",
          tags: ["state:pending"],
          on: {
            NEXT: "Preparing"
          }
        },
        Attempting: {
          tags: ["state:attempting"],
          invoke: {
            id: "attemptEmailLinkVerification",
            src: "attemptEmailLinkVerification",
            input: ({ context }) => ({
              parent: context.parent
            })
          },
          after: {
            emailLinkTimeout: {
              description: "Timeout after 5 minutes",
              target: "Pending",
              actions: (0, import_xstate6.sendTo)(({ context }) => context.formRef, {
                type: "ERRORS.SET",
                error: new ClerkElementsError("verify-email-link-timeout", "Email link verification timed out")
              })
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: (0, import_xstate6.log)(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        }
      }
    },
    EmailCode: {
      tags: ["verification:method:email", "verification:category:code", "verification:email_code"],
      initial: "Preparing",
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          exit: "resendableReset",
          invoke: {
            id: "prepareEmailAddressCodeVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "email_code"
              }
            }),
            onDone: [
              {
                guard: "shouldVerifyEmailCode",
                target: "Pending"
              },
              {
                actions: [
                  (0, import_xstate6.assign)({ resource: ({ event }) => event.output }),
                  (0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output }))
                ]
              }
            ],
            onError: {
              actions: "setFormErrors",
              target: "Pending"
            }
          }
        },
        Pending: {
          tags: ["state:pending"],
          on: {
            RETRY: "Preparing",
            SUBMIT: {
              target: "Attempting",
              reenter: true
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: (0, import_xstate6.log)(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        },
        Attempting: {
          tags: ["state:attempting", "state:loading"],
          entry: "sendToLoading",
          invoke: {
            id: "attemptEmailAddressCodeVerification",
            src: "attempt",
            input: ({ context }) => {
              var _a;
              return {
                parent: context.parent,
                params: {
                  strategy: "email_code",
                  code: ((_a = context.formRef.getSnapshot().context.fields.get("code")) == null ? void 0 : _a.value) || ""
                }
              };
            },
            onDone: {
              actions: [(0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output })), "sendToLoading"]
            },
            onError: {
              actions: ["setFormErrors", "sendToLoading"],
              target: "Pending"
            }
          }
        }
      }
    },
    PhoneCode: {
      tags: ["verification:method:phone", "verification:category:code", "verification:phone_code"],
      initial: "Preparing",
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          exit: "resendableReset",
          invoke: {
            id: "preparePhoneCodeVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "phone_code"
              }
            }),
            onDone: [
              {
                guard: "shouldVerifyPhoneCode",
                target: "Pending",
                actions: (0, import_xstate6.assign)({ resource: ({ event }) => event.output })
              },
              {
                actions: [
                  (0, import_xstate6.assign)({ resource: ({ event }) => event.output }),
                  (0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output }))
                ]
              }
            ],
            onError: {
              actions: "setFormErrors",
              target: "Pending"
            }
          }
        },
        Pending: {
          tags: ["state:pending"],
          on: {
            RETRY: "Preparing",
            SUBMIT: {
              target: "Attempting",
              reenter: true
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: (0, import_xstate6.log)(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        },
        Attempting: {
          tags: ["state:attempting", "state:loading"],
          entry: "sendToLoading",
          invoke: {
            id: "attemptPhoneNumberVerification",
            src: "attempt",
            input: ({ context }) => {
              var _a;
              return {
                parent: context.parent,
                params: {
                  strategy: "phone_code",
                  code: ((_a = context.formRef.getSnapshot().context.fields.get("code")) == null ? void 0 : _a.value) || ""
                }
              };
            },
            onDone: {
              actions: [(0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output })), "sendToLoading"]
            },
            onError: {
              actions: ["setFormErrors", "sendToLoading"],
              target: "Pending"
            }
          }
        }
      }
    }
  }
});

// src/internals/machines/sign-up/router.machine.ts
var SignUpRouterMachineId = "SignUpRouter";
var isCurrentPath = (path) => ({ context }, _params) => {
  var _a, _b;
  return (_b = (_a = context.router) == null ? void 0 : _a.match(path)) != null ? _b : false;
};
var needsStatus = (status) => ({ context, event }, _) => {
  var _a, _b, _c, _d;
  return ((_a = event == null ? void 0 : event.resource) == null ? void 0 : _a.status) === status || ((_d = (_c = (_b = context.clerk) == null ? void 0 : _b.client) == null ? void 0 : _c.signUp) == null ? void 0 : _d.status) === status;
};
var SignUpRouterMachine = (0, import_xstate7.setup)({
  actors: {
    continueMachine: SignUpContinueMachine,
    startMachine: SignUpStartMachine,
    thirdPartyMachine: ThirdPartyMachine,
    verificationMachine: SignUpVerificationMachine
  },
  actions: {
    clearFormErrors: (0, import_xstate7.sendTo)(({ context }) => context.formRef, { type: "ERRORS.CLEAR" }),
    logUnknownError: (snapshot) => console.error("Unknown error:", snapshot),
    navigateInternal: ({ context }, { path, force = false }) => {
      if (!context.router) {
        return;
      }
      if (!force && shouldUseVirtualRouting()) {
        return;
      }
      if (context.exampleMode) {
        return;
      }
      const resolvedPath = (0, import_url.joinURL)(context.router.basePath, path);
      if (resolvedPath === context.router.pathname()) {
        return;
      }
      context.router.shallowPush(resolvedPath);
    },
    navigateExternal: ({ context }, { path }) => {
      var _a;
      return (_a = context.router) == null ? void 0 : _a.push(path);
    },
    raiseNext: (0, import_xstate7.raise)({ type: "NEXT" }),
    setActive: ({ context, event }, params) => {
      if (context.exampleMode) {
        return;
      }
      const session = (params == null ? void 0 : params.sessionId) || (params == null ? void 0 : params.useLastActiveSession) && context.clerk.client.lastActiveSessionId || ((event == null ? void 0 : event.resource) || context.clerk.client.signUp).createdSessionId;
      const beforeEmit = () => {
        var _a, _b;
        return (_b = context.router) == null ? void 0 : _b.push(((_a = context.router) == null ? void 0 : _a.searchParams().get("redirect_url")) || context.clerk.buildAfterSignUpUrl());
      };
      void context.clerk.setActive({ session, beforeEmit });
    },
    delayedReset: (0, import_xstate7.raise)({ type: "RESET" }, { delay: 3e3 }),
    // Reset machine after 3s delay.
    setError: (0, import_xstate7.assign)({
      error: (_, { error }) => {
        if (error) {
          return error;
        }
        return new ClerkElementsRuntimeError("Unknown error");
      }
    }),
    setFormOAuthErrors: ({ context }) => {
      const errorOrig = context.clerk.client.signIn.firstFactorVerification.error;
      if (!errorOrig) {
        return;
      }
      let error;
      switch (errorOrig.code) {
        case ERROR_CODES.NOT_ALLOWED_TO_SIGN_UP:
        case ERROR_CODES.OAUTH_ACCESS_DENIED:
        case ERROR_CODES.NOT_ALLOWED_ACCESS:
        case ERROR_CODES.SAML_USER_ATTRIBUTE_MISSING:
        case ERROR_CODES.OAUTH_EMAIL_DOMAIN_RESERVED_BY_SAML:
        case ERROR_CODES.USER_LOCKED:
          error = new ClerkElementsError(errorOrig.code, errorOrig.longMessage);
          break;
        default:
          error = new ClerkElementsError(
            "unable_to_complete",
            "Unable to complete action at this time. If the problem persists please contact support."
          );
      }
      context.formRef.send({
        type: "ERRORS.SET",
        error
      });
    },
    transfer: ({ context }) => {
      var _a;
      return (_a = context.router) == null ? void 0 : _a.push(context.clerk.buildSignInUrl());
    }
  },
  guards: {
    areFieldsMissing: ({ context }) => {
      var _a, _b, _c, _d;
      return ((_d = (_c = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signUp) == null ? void 0 : _c.missingFields) == null ? void 0 : _d.length) > 0;
    },
    areFieldsUnverified: ({ context }) => {
      var _a, _b, _c, _d;
      return ((_d = (_c = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signUp) == null ? void 0 : _c.unverifiedFields) == null ? void 0 : _d.length) > 0;
    },
    hasAuthenticatedViaClerkJS: ({ context }) => Boolean(context.clerk.client.signUp.status === null && context.clerk.client.lastActiveSessionId),
    hasCreatedSession: ({ context }) => {
      var _a;
      return Boolean((_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.createdSession));
    },
    hasClerkStatus: ({ context }, params) => {
      var _a;
      const value = (_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.status);
      if (!params) {
        return Boolean(value);
      }
      return value === params.status;
    },
    hasClerkTransfer: ({ context }) => {
      var _a;
      return Boolean((_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.transfer));
    },
    hasResource: ({ context }) => Boolean(context.clerk.client.signUp),
    hasTicket: ({ context }) => Boolean(context.ticket),
    isLoggedInAndSingleSession: (0, import_xstate7.and)(["isLoggedIn", "isSingleSessionMode", (0, import_xstate7.not)("isExampleMode")]),
    isStatusAbandoned: needsStatus("abandoned"),
    isStatusComplete: ({ context, event }) => {
      var _a, _b;
      const resource = event == null ? void 0 : event.resource;
      const signUp = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signUp;
      return (resource == null ? void 0 : resource.status) === "complete" && Boolean(resource == null ? void 0 : resource.createdSessionId) || (signUp == null ? void 0 : signUp.status) === "complete" && Boolean(signUp == null ? void 0 : signUp.createdSessionId);
    },
    isStatusMissingRequirements: needsStatus("missing_requirements"),
    isLoggedIn: (0, import_xstate7.or)(["isStatusComplete", ({ context }) => Boolean(context.clerk.user)]),
    isSingleSessionMode: ({ context }) => {
      var _a, _b;
      return Boolean((_b = (_a = context.clerk) == null ? void 0 : _a.__unstable__environment) == null ? void 0 : _b.authConfig.singleSessionMode);
    },
    isExampleMode: ({ context }) => Boolean(context.exampleMode),
    isMissingRequiredFields: (0, import_xstate7.and)(["isStatusMissingRequirements", "areFieldsMissing"]),
    isMissingRequiredUnverifiedFields: (0, import_xstate7.and)(["isStatusMissingRequirements", "areFieldsUnverified"]),
    needsIdentifier: (0, import_xstate7.or)(["statusNeedsIdentifier", isCurrentPath("/")]),
    needsContinue: (0, import_xstate7.and)(["statusNeedsContinue", isCurrentPath("/continue")]),
    needsVerification: (0, import_xstate7.and)(["statusNeedsVerification", isCurrentPath("/verify")]),
    needsCallback: isCurrentPath(SSO_CALLBACK_PATH_ROUTE),
    statusNeedsIdentifier: (0, import_xstate7.or)([(0, import_xstate7.not)("hasResource"), "isStatusAbandoned"]),
    statusNeedsContinue: (0, import_xstate7.or)(["isMissingRequiredFields"]),
    statusNeedsVerification: (0, import_xstate7.or)(["isMissingRequiredUnverifiedFields", (0, import_xstate7.and)(["areFieldsMissing", "hasClerkStatus"])])
  },
  delays: {
    "TIMEOUT.POLLING": 3e5
    // 5 minutes
  },
  types: {}
}).createMachine({
  id: SignUpRouterMachineId,
  // @ts-expect-error - Set in INIT event
  context: {},
  initial: "Idle",
  on: {
    "AUTHENTICATE.OAUTH": {
      actions: (0, import_xstate7.sendTo)(ThirdPartyMachineId, ({ context, event }) => {
        var _a, _b, _c, _d;
        return {
          type: "REDIRECT",
          params: {
            strategy: event.strategy,
            redirectUrl: `${((_a = context.router) == null ? void 0 : _a.mode) === ROUTING.virtual ? (_b = context.clerk.__unstable__environment) == null ? void 0 : _b.displayConfig.signUpUrl : (_c = context.router) == null ? void 0 : _c.basePath}${SSO_CALLBACK_PATH_ROUTE}`,
            redirectUrlComplete: ((_d = context.router) == null ? void 0 : _d.searchParams().get("redirect_url")) || context.clerk.buildAfterSignUpUrl()
          }
        };
      })
    },
    "AUTHENTICATE.SAML": {
      actions: (0, import_xstate7.sendTo)(ThirdPartyMachineId, ({ context }) => {
        var _a, _b, _c, _d, _e;
        return {
          type: "REDIRECT",
          params: {
            strategy: "saml",
            emailAddress: (_a = context.formRef.getSnapshot().context.fields.get("emailAddress")) == null ? void 0 : _a.value,
            redirectUrl: `${((_b = context.router) == null ? void 0 : _b.mode) === ROUTING.virtual ? (_c = context.clerk.__unstable__environment) == null ? void 0 : _c.displayConfig.signUpUrl : (_d = context.router) == null ? void 0 : _d.basePath}${SSO_CALLBACK_PATH_ROUTE}`,
            redirectUrlComplete: ((_e = context.router) == null ? void 0 : _e.searchParams().get("redirect_url")) || context.clerk.buildAfterSignUpUrl()
          }
        };
      })
    },
    "AUTHENTICATE.WEB3": {
      actions: (0, import_xstate7.sendTo)("start", ({ event }) => event)
    },
    "FORM.ATTACH": {
      description: "Attach/re-attach the form to the router.",
      actions: (0, import_xstate7.enqueueActions)(({ enqueue, event }) => {
        enqueue.assign({
          formRef: event.formRef
        });
        enqueue.raise({ type: "RESET.STEP" });
      })
    },
    "NAVIGATE.PREVIOUS": ".Hist",
    "NAVIGATE.START": ".Start",
    LOADING: {
      actions: (0, import_xstate7.assign)(({ event }) => ({
        loading: {
          isLoading: event.isLoading,
          step: event.step,
          strategy: event.strategy,
          action: event.action
        }
      }))
    },
    RESET: ".Idle"
  },
  states: {
    Idle: {
      on: {
        INIT: {
          actions: (0, import_xstate7.assign)(({ event }) => {
            var _a;
            const searchParams = (_a = event.router) == null ? void 0 : _a.searchParams();
            return {
              clerk: event.clerk,
              router: event.router,
              signInPath: event.signInPath || SIGN_IN_DEFAULT_BASE_PATH,
              loading: {
                isLoading: false
              },
              exampleMode: event.exampleMode || false,
              formRef: event.formRef,
              ticket: (searchParams == null ? void 0 : searchParams.get(SEARCH_PARAMS.ticket)) || (searchParams == null ? void 0 : searchParams.get(SEARCH_PARAMS.invitationToken)) || void 0
            };
          }),
          target: "Init"
        }
      }
    },
    Init: {
      entry: (0, import_xstate7.enqueueActions)(({ context, enqueue, self }) => {
        var _a, _b;
        if (!self.getSnapshot().children[ThirdPartyMachineId]) {
          enqueue.spawnChild("thirdPartyMachine", {
            id: ThirdPartyMachineId,
            systemId: ThirdPartyMachineId,
            input: {
              basePath: (_b = (_a = context.router) == null ? void 0 : _a.basePath) != null ? _b : SIGN_UP_DEFAULT_BASE_PATH,
              flow: "signUp",
              formRef: context.formRef,
              parent: self
            }
          });
        }
      }),
      always: [
        {
          guard: "isLoggedInAndSingleSession",
          actions: [
            (0, import_xstate7.log)("Already logged in"),
            {
              type: "navigateExternal",
              params: ({ context }) => {
                var _a;
                return {
                  path: ((_a = context.router) == null ? void 0 : _a.searchParams().get("redirect_url")) || context.clerk.buildAfterSignUpUrl()
                };
              }
            }
          ]
        },
        {
          guard: "needsCallback",
          target: "Callback"
        },
        {
          guard: "hasTicket",
          actions: { type: "navigateInternal", params: { force: true, path: "/" } },
          target: "Start"
        },
        {
          guard: "needsVerification",
          actions: { type: "navigateInternal", params: { force: true, path: "/verify" } },
          target: "Verification"
        },
        {
          guard: (0, import_xstate7.or)(["needsContinue", "hasClerkTransfer"]),
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } },
          target: "Continue"
        },
        {
          actions: { type: "navigateInternal", params: { force: true, path: "/" } },
          target: "Start"
        }
      ]
    },
    Start: {
      tags: ["step:start"],
      exit: "clearFormErrors",
      invoke: {
        id: "start",
        src: "startMachine",
        input: ({ context, self }) => {
          var _a;
          return {
            basePath: (_a = context.router) == null ? void 0 : _a.basePath,
            formRef: context.formRef,
            parent: self,
            ticket: context.ticket
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "Start",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: (0, import_xstate7.and)(["hasTicket", "statusNeedsContinue"]),
            actions: { type: "navigateInternal", params: { path: "/" } },
            target: "Start"
          },
          {
            guard: "statusNeedsVerification",
            target: "Verification",
            actions: { type: "navigateInternal", params: { path: "/verify" } }
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          }
        ]
      }
    },
    Continue: {
      tags: ["step:continue"],
      invoke: {
        id: "continue",
        src: "continueMachine",
        input: ({ context, self }) => {
          var _a;
          return {
            basePath: (_a = context.router) == null ? void 0 : _a.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "Continue",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            target: "Verification",
            actions: { type: "navigateInternal", params: { path: "/verify" } }
          }
        ]
      }
    },
    Verification: {
      tags: ["step:verification"],
      invoke: {
        id: "verification",
        src: "verificationMachine",
        input: ({ context, self }) => {
          var _a, _b;
          return {
            attributes: (_a = context.clerk.__unstable__environment) == null ? void 0 : _a.userSettings.attributes,
            basePath: (_b = context.router) == null ? void 0 : _b.basePath,
            formRef: context.formRef,
            parent: self,
            resource: context.clerk.client.signUp
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      always: [
        {
          guard: "hasCreatedSession",
          actions: [
            ({ context }) => {
              var _a;
              return {
                type: "setActive",
                params: { sessionId: (_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.createdSession) }
              };
            },
            "delayedReset"
          ]
        },
        {
          guard: { type: "hasClerkStatus", params: { status: "verified" } },
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } }
        },
        {
          guard: { type: "hasClerkStatus", params: { status: "expired" } },
          actions: { type: "navigateInternal", params: { force: true, path: "/" } }
        }
      ],
      on: {
        "RESET.STEP": {
          target: "Verification",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          }
        ]
      }
    },
    Callback: {
      tags: ["step:callback"],
      entry: (0, import_xstate7.sendTo)(ThirdPartyMachineId, { type: "CALLBACK" }),
      on: {
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            description: "Handle a case where the user has already been authenticated via ClerkJS",
            guard: "hasAuthenticatedViaClerkJS",
            actions: [{ type: "setActive", params: { useLastActiveSession: true } }, "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            actions: { type: "navigateInternal", params: { path: "/verify" } },
            target: "Verification"
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          },
          {
            actions: { type: "navigateInternal", params: { path: "/" } },
            target: "Start"
          }
        ]
      }
    },
    Error: {
      tags: ["step:error"],
      on: {
        NEXT: {
          target: "Start",
          actions: "clearFormErrors"
        }
      }
    },
    Hist: {
      type: "history",
      exit: "clearFormErrors"
    }
  }
});

// src/react/router/index.ts
var import_router2 = require("@clerk/shared/router");

// src/react/router/virtual.ts
var import_react2 = require("react");
var DUMMY_ORIGIN = "https://clerk.dummy";
var _url, _listeners;
var VirtualRouter = class {
  constructor(path) {
    this.name = "VirtualRouter";
    this.mode = "virtual";
    __privateAdd(this, _url);
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    const origin = typeof window === "undefined" ? DUMMY_ORIGIN : window.location.origin;
    __privateSet(this, _url, new URL(path != null ? path : "/", origin));
  }
  push(path) {
    const newUrl = new URL(__privateGet(this, _url).toString());
    newUrl.pathname = path;
    __privateSet(this, _url, newUrl);
    this.emit();
  }
  replace(path) {
    this.push(path);
  }
  shallowPush(path) {
    this.push(path);
  }
  pathname() {
    return __privateGet(this, _url).pathname;
  }
  searchParams() {
    return __privateGet(this, _url).searchParams;
  }
  subscribe(listener) {
    __privateGet(this, _listeners).add(listener);
    return () => __privateGet(this, _listeners).delete(listener);
  }
  emit() {
    __privateGet(this, _listeners).forEach((listener) => listener(__privateGet(this, _url)));
  }
  getSnapshot() {
    return __privateGet(this, _url);
  }
};
_url = new WeakMap();
_listeners = new WeakMap();
var virtualRouter = new VirtualRouter("/");
var useVirtualRouter = () => {
  const url = (0, import_react2.useSyncExternalStore)(
    virtualRouter.subscribe.bind(virtualRouter),
    virtualRouter.getSnapshot.bind(virtualRouter)
  );
  return {
    mode: virtualRouter.mode,
    name: virtualRouter.name,
    pathname: () => url.pathname,
    push: virtualRouter.push.bind(virtualRouter),
    replace: virtualRouter.replace.bind(virtualRouter),
    searchParams: () => url.searchParams,
    shallowPush: virtualRouter.shallowPush.bind(virtualRouter)
  };
};

// src/react/utils/create-context-from-actor-ref.ts
var import_react3 = require("@xstate/react");
var React = __toESM(require("react"));
function createContextFromActorRef(displayName) {
  const ReactContext = React.createContext(null);
  const OriginalProvider = ReactContext.Provider;
  function Provider({ children, actorRef }) {
    return React.createElement(
      OriginalProvider,
      {
        value: actorRef
      },
      children
    );
  }
  Provider.displayName = displayName;
  function useContext2(allowMissingActor = false) {
    const actorRef = React.useContext(ReactContext);
    if (!allowMissingActor && !actorRef) {
      throw new Error(
        `You used a hook from "${Provider.displayName}" but it's not inside a <${Provider.displayName}.Provider> component.`
      );
    }
    return actorRef;
  }
  function useSelector4(selector, compare) {
    const actor2 = useContext2();
    return (0, import_react3.useSelector)(actor2, selector, compare);
  }
  return {
    Provider,
    useActorRef: useContext2,
    useSelector: useSelector4
  };
}

// src/react/sign-up/context/router.context.ts
var SignUpRouterCtx = createContextFromActorRef("SignUpRouterCtx");
function useSignUpStep(name) {
  return SignUpRouterCtx.useSelector((state) => state.children[name]);
}
var useSignUpStartStep = () => useSignUpStep("start");
var useSignUpContinueStep = () => useSignUpStep("continue");
var useSignUpVerificationStep = () => useSignUpStep("verification");

// src/react/common/form/hooks/use-form.ts
var import_react4 = require("react");

// src/react/common/form/hooks/use-global-errors.ts
function useGlobalErrors() {
  const errors = useFormSelector(globalErrorsSelector);
  return {
    errors
  };
}

// src/react/common/form/hooks/use-form.ts
function useForm({ flowActor }) {
  const { errors } = useGlobalErrors();
  const onSubmit = (0, import_react4.useCallback)(
    (event) => {
      event.preventDefault();
      if (flowActor) {
        flowActor.send({ type: "SUBMIT", action: "submit" });
      }
    },
    [flowActor]
  );
  return {
    props: {
      ...errors.length > 0 ? { "data-global-error": true } : {},
      onSubmit
    }
  };
}

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// src/react/common/form/form.tsx
var import_react_form = require("@radix-ui/react-form");
var React2 = __toESM(require("react"));
var import_jsx_runtime = require("react/jsx-runtime");
var DISPLAY_NAME = "ClerkElementsForm";
var Form = React2.forwardRef(({ flowActor, onSubmit, ...rest }, forwardedRef) => {
  const form = useForm({ flowActor });
  const { onSubmit: internalOnSubmit, ...internalFormProps } = form.props;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_react_form.Form,
    {
      ...internalFormProps,
      ...rest,
      onSubmit: composeEventHandlers(internalOnSubmit, onSubmit),
      ref: forwardedRef
    }
  );
});
Form.displayName = DISPLAY_NAME;

// src/react/common/form/submit.tsx
var import_react_form2 = require("@radix-ui/react-form");
var DISPLAY_NAME2 = "ClerkElementsSubmit";
var Submit = import_react_form2.Submit;
Submit.displayName = DISPLAY_NAME2;

// src/react/utils/path-inference/next.tsx
var import_router4 = require("next/compat/router");
var import_navigation = require("next/navigation");
var import_react5 = __toESM(require("react"));

// src/react/utils/path-inference/utils.ts
function removeOptionalCatchAllSegment(pathname) {
  return pathname.replace(/\/\[\[\.\.\..*/, "");
}

// src/react/utils/path-inference/next.tsx
var usePathnameWithoutCatchAll = () => {
  const pathRef = import_react5.default.useRef();
  const pagesRouter = (0, import_router4.useRouter)();
  if (pagesRouter) {
    if (pathRef.current) {
      return pathRef.current;
    } else {
      pathRef.current = removeOptionalCatchAllSegment(pagesRouter.pathname);
      return pathRef.current;
    }
  }
  const pathname = (0, import_navigation.usePathname)() || "";
  const pathParts = pathname.split("/").filter(Boolean);
  const catchAllParams = Object.values((0, import_navigation.useParams)() || {}).filter((v) => Array.isArray(v)).flat(Infinity);
  if (pathRef.current) {
    return pathRef.current;
  } else {
    pathRef.current = `/${pathParts.slice(0, pathParts.length - catchAllParams.length).join("/")}`;
    return pathRef.current;
  }
};

// src/react/sign-up/root.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var actor = (0, import_xstate8.createActor)(SignUpRouterMachine, { inspect });
actor.start();
function SignUpFlowProvider({ children, exampleMode, fallback, isRootPath }) {
  const clerk = (0, import_react6.useClerk)();
  const router = (0, import_router2.useClerkRouter)();
  const formRef = useFormStore();
  const isReady = (0, import_react7.useSelector)(actor, (state) => state.value !== "Idle");
  (0, import_react8.useEffect)(() => {
    if (!clerk || !router) {
      return;
    }
    const cb = () => {
      const evt = {
        type: "INIT",
        clerk,
        exampleMode,
        formRef,
        router,
        signInPath: SIGN_IN_DEFAULT_BASE_PATH
      };
      if (actor.getSnapshot().can(evt)) {
        actor.send(evt);
      }
      if (formRef && actor.getSnapshot().can({ type: "RESET.STEP" })) {
        actor.send({
          type: "FORM.ATTACH",
          formRef
        });
      }
    };
    if ("addOnLoaded" in clerk) {
      clerk.addOnLoaded(cb);
    } else {
      cb();
    }
  }, [clerk, exampleMode, formRef == null ? void 0 : formRef.id, !!router, clerk.loaded]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(SignUpRouterCtx.Provider, { actorRef: actor, children: [
    isRootPath && !isReady && fallback ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Form, { children: fallback }) : null,
    clerk.loaded && isReady ? children : null
  ] });
}
function SignUpRoot({
  children,
  exampleMode = false,
  fallback = null,
  path: pathProp,
  routing = ROUTING.path
}) {
  var _a;
  const clerk = (0, import_react6.useClerk)();
  const inferredPath = usePathnameWithoutCatchAll();
  const path = pathProp || inferredPath || SIGN_UP_DEFAULT_BASE_PATH;
  (_a = clerk.telemetry) == null ? void 0 : _a.record(
    (0, import_telemetry.eventComponentMounted)("Elements_SignUpRoot", {
      exampleMode,
      fallback: Boolean(fallback),
      path,
      routing
    })
  );
  const router = (routing === ROUTING.virtual ? useVirtualRouter : import_router5.useClerkHostRouter)();
  const isRootPath = path === router.pathname();
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    import_router2.Router,
    {
      basePath: path,
      router,
      children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(FormStoreProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        SignUpFlowProvider,
        {
          exampleMode,
          fallback,
          isRootPath,
          children
        }
      ) })
    }
  );
}

// src/react/sign-up/step.tsx
var import_react10 = require("@clerk/shared/react");
var import_telemetry2 = require("@clerk/shared/telemetry");

// src/react/hooks/use-active-tags.hook.ts
var import_react9 = require("@xstate/react");
var ActiveTagsMode = {
  any: "any",
  all: "all"
};
function useActiveTags(actor2, tags, mode = ActiveTagsMode.any) {
  const state = (0, import_react9.useSelector)(
    actor2,
    (s) => s,
    (prev, next) => prev.tags === next.tags
  );
  if (!state) {
    return false;
  }
  if (typeof tags === "string") {
    return state.hasTag(tags);
  }
  if (!Array.isArray(tags)) {
    throw new Error("Invalid tags parameter provided to useActiveTags");
  }
  switch (mode) {
    case ActiveTagsMode.any: {
      const matching = new Set(tags.filter((tag) => state.hasTag(tag)));
      return { active: matching.size > 0, activeTags: matching };
    }
    case ActiveTagsMode.all:
      return tags.length === state.tags.size ? tags.every((tag) => state.hasTag(tag)) : false;
    default:
      return false;
  }
}

// src/react/sign-up/continue.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var SignUpContinueCtx = createContextFromActorRef("SignUpContinueCtx");
function SignUpContinue(props) {
  const routerRef = SignUpRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "step:continue");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SignUpContinueInner, { ...props }) : null;
}
function SignUpContinueInner(props) {
  const ref = useSignUpContinueStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SignUpContinueCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}

// src/react/sign-up/start.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var SignUpStartCtx = createContextFromActorRef("SignUpStartCtx");
function SignUpStart(props) {
  const routerRef = SignUpRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "step:start");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SignUpStartInner, { ...props }) : null;
}
function SignUpStartInner(props) {
  const ref = useSignUpStartStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SignUpStartCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}

// src/react/sign-up/verifications.tsx
var import_jsx_runtime5 = require("react/jsx-runtime");
var SignUpVerificationCtx = createContextFromActorRef("SignUpVerificationCtx");
function SignUpVerifications(props) {
  const ref = SignUpRouterCtx.useActorRef();
  const activeState = useActiveTags(ref, "step:verification");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SignUpVerifyInner, { ...props }) : null;
}
function SignUpVerifyInner(props) {
  const ref = useSignUpVerificationStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SignUpVerificationCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}
function SignUpStrategy({ children, name: tag }) {
  const ref = SignUpVerificationCtx.useActorRef(true);
  if (!ref) {
    throw new Error(
      '<Strategy> used outside of <SignUp>. Did you mean to `import { Strategy } from "@clerk/elements/sign-in"` instead?'
    );
  }
  const { active } = useActiveTags(ref, [
    `verification:${tag}`,
    `verification:category:${tag}`
  ]);
  return active ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children }) : null;
}

// src/react/sign-up/step.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var SIGN_UP_STEPS = {
  start: "start",
  continue: "continue",
  verifications: "verifications"
};
function SignUpStep(props) {
  var _a;
  const clerk = (0, import_react10.useClerk)();
  (_a = clerk.telemetry) == null ? void 0 : _a.record((0, import_telemetry2.eventComponentMounted)("Elements_SignUpStep", { name: props.name }));
  switch (props.name) {
    case SIGN_UP_STEPS.start:
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SignUpStart, { ...props });
    case SIGN_UP_STEPS.continue:
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SignUpContinue, { ...props });
    case SIGN_UP_STEPS.verifications:
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SignUpVerifications, { ...props });
    default:
      throw new ClerkElementsRuntimeError(`Invalid step name. Use 'start', 'continue', or 'verifications'.`);
  }
}

// src/react/sign-up/action/action.tsx
var React6 = __toESM(require("react"));

// src/react/common/index.ts
var import_client_only = require("client-only");

// src/react/sign-up/action/navigate.tsx
var import_react_slot = require("@radix-ui/react-slot");
var React4 = __toESM(require("react"));
var import_jsx_runtime7 = require("react/jsx-runtime");
var SIGN_UP_NAVIGATE_NAME = "SignInNavigate";
var SignUpNavigationEventMap = {
  start: `NAVIGATE.START`,
  previous: `NAVIGATE.PREVIOUS`
};
var SignUpNavigate = React4.forwardRef(
  ({ asChild, to, ...rest }, forwardedRef) => {
    const actorRef = SignUpRouterCtx.useActorRef();
    const Comp = asChild ? import_react_slot.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    const sendEvent = React4.useCallback(() => {
      const type = SignUpNavigationEventMap[to];
      if (actorRef.getSnapshot().can({ type })) {
        actorRef.send({ type });
      } else {
        console.warn(
          `Clerk: <SignUp.Action navigate="${to}"> is an invalid navigation event. You can only navigate to: ${Object.keys(SignUpNavigationEventMap).join(", ")}.`
        );
      }
    }, [actorRef, to]);
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        onClick: sendEvent,
        ref: forwardedRef
      }
    );
  }
);
SignUpNavigate.displayName = SIGN_UP_NAVIGATE_NAME;

// src/react/sign-up/action/resend.tsx
var import_react_slot2 = require("@radix-ui/react-slot");
var import_react11 = require("@xstate/react");
var React5 = __toESM(require("react"));
var import_jsx_runtime8 = require("react/jsx-runtime");
var SIGN_UP_RESEND_NAME = "SignUpResend";
var SignUpResend = React5.forwardRef(
  ({ asChild, fallback, ...rest }, forwardedRef) => {
    const ref = SignUpVerificationCtx.useActorRef(true);
    if (!ref) {
      throw new Error('The resend action must be used within <SignUp.Step name="verifications">.');
    }
    const fallbackProps = (0, import_react11.useSelector)(
      ref,
      (state) => ({
        resendable: state.context.resendable,
        resendableAfter: state.context.resendableAfter
      }),
      (a, b) => a.resendableAfter === b.resendableAfter && a.resendable === b.resendable
    );
    if (fallback && !fallbackProps.resendable) {
      return typeof fallback === "function" ? fallback(fallbackProps) : fallback;
    }
    const Comp = asChild ? import_react_slot2.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        disabled: !fallbackProps.resendable,
        onClick: () => ref.send({ type: "RETRY" }),
        ref: forwardedRef
      }
    );
  }
);
SignUpResend.displayName = SIGN_UP_RESEND_NAME;

// src/react/sign-up/action/action.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
var SignUpAction = React6.forwardRef((props, forwardedRef) => {
  const { submit, navigate, resend, ...rest } = props;
  let Comp;
  if (submit) {
    Comp = Submit;
  } else if (navigate) {
    Comp = SignUpNavigate;
  } else if (resend) {
    Comp = SignUpResend;
  }
  return Comp ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    Comp,
    {
      to: navigate,
      ...rest,
      ref: forwardedRef
    }
  ) : null;
});
SignUpAction.displayName = "SignUpAction";

// src/react/sign-up/captcha.tsx
var import_react_slot3 = require("@radix-ui/react-slot");
var React7 = __toESM(require("react"));
var import_jsx_runtime10 = require("react/jsx-runtime");
var SignUpCaptcha = React7.forwardRef(
  ({ asChild, children, ...rest }, forwardedRef) => {
    const ref = SignUpStartCtx.useActorRef(true);
    if (!ref) {
      throw new ClerkElementsRuntimeError('<Captcha> must be used within the <SignUp.Step name="start"> component.');
    }
    const Comp = asChild ? import_react_slot3.Slot : "div";
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
      Comp,
      {
        id: CAPTCHA_ELEMENT_ID,
        ...rest,
        ref: forwardedRef
      }
    );
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Action,
  Captcha,
  Root,
  SignUp,
  Step,
  Strategy
});
//# sourceMappingURL=index.js.map