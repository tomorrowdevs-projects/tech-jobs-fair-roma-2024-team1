"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/react/sign-in/index.ts
var sign_in_exports = {};
__export(sign_in_exports, {
  Action: () => SignInAction,
  FirstFactor: () => SignInFirstFactor,
  Passkey: () => SignInPasskey,
  Root: () => SignInRoot,
  SafeIdentifier: () => SignInSafeIdentifier,
  Salutation: () => SignInSalutation,
  SecondFactor: () => SignInSecondFactor,
  SessionList: () => SignInSessionList,
  SessionListItem: () => SignInSessionListItem,
  SignIn: () => SignInRoot,
  Step: () => SignInStep,
  Strategy: () => SignInStrategy,
  SupportedStrategy: () => SignInSupportedStrategy
});
module.exports = __toCommonJS(sign_in_exports);
var import_client_only2 = require("client-only");

// src/react/sign-in/root.tsx
var import_react8 = require("@clerk/shared/react");
var import_router6 = require("@clerk/shared/router");
var import_telemetry = require("@clerk/shared/telemetry");
var import_react9 = require("@xstate/react");
var import_react10 = require("react");
var import_xstate8 = require("xstate");

// src/utils/safe-access.ts
function safeAccess(fn, fallback) {
  try {
    return fn();
  } catch (e) {
    return fallback;
  }
}

// src/internals/constants/index.ts
var SSO_CALLBACK_PATH_ROUTE = "/sso-callback";
var CHOOSE_SESSION_PATH_ROUTE = "/choose";
var MAGIC_LINK_VERIFY_PATH_ROUTE = "/verify";
var SIGN_IN_DEFAULT_BASE_PATH = safeAccess(
  () => {
    var _a;
    return (_a = process.env.CLERK_SIGN_IN_URL) != null ? _a : process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL;
  },
  "/sign-in"
);
var SIGN_UP_DEFAULT_BASE_PATH = safeAccess(
  () => {
    var _a;
    return (_a = process.env.CLERK_SIGN_UP_URL) != null ? _a : process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL;
  },
  "/sign-up"
);
var NEXT_WINDOW_HISTORY_SUPPORT_VERSION = "14.1.0";
var RESENDABLE_COUNTDOWN_DEFAULT = 60;
var ERROR_CODES = {
  FORM_IDENTIFIER_NOT_FOUND: "form_identifier_not_found",
  FORM_PASSWORD_INCORRECT: "form_password_incorrect",
  INVALID_STRATEGY_FOR_USER: "strategy_for_user_invalid",
  NOT_ALLOWED_TO_SIGN_UP: "not_allowed_to_sign_up",
  OAUTH_ACCESS_DENIED: "oauth_access_denied",
  OAUTH_EMAIL_DOMAIN_RESERVED_BY_SAML: "oauth_email_domain_reserved_by_saml",
  NOT_ALLOWED_ACCESS: "not_allowed_access",
  SAML_USER_ATTRIBUTE_MISSING: "saml_user_attribute_missing",
  USER_LOCKED: "user_locked"
};
var ROUTING = {
  path: "path",
  virtual: "virtual"
};

// src/internals/machines/form/form.context.ts
var import_react = require("@xstate/react");

// src/internals/machines/form/form.machine.ts
var import_error = require("@clerk/shared/error");
var import_underscore = require("@clerk/shared/underscore");
var import_xstate = require("xstate");

// src/internals/errors/index.ts
var ClerkElementsErrorBase = class extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.clerkError = true;
    this.clerkElementsError = true;
    this.name = "ClerkElementsError";
    this.rawMessage = message;
  }
  toString() {
    return `[${this.name}]
Code: ${this.code}
Message: ${this.message}`;
  }
};
var ClerkElementsError = class _ClerkElementsError extends ClerkElementsErrorBase {
  static fromAPIError(error) {
    return new _ClerkElementsError(
      error.code.toString(),
      // @ts-expect-error - Expected that longMessage isn't a property of MetamaskError
      error.longMessage || error.message
    );
  }
  constructor(code, message) {
    super(code, message);
    this.name = "ClerkElementsError";
  }
};
var ClerkElementsRuntimeError = class extends ClerkElementsErrorBase {
  constructor(message) {
    super("elements_runtime_error", message);
    this.name = "ClerkElementsRuntimeError";
  }
};
var ClerkElementsFieldError = class _ClerkElementsFieldError extends ClerkElementsErrorBase {
  constructor(code, message) {
    super(code, message);
    this.matchFn = () => true;
    this.name = "ClerkElementsFieldError";
  }
  static fromAPIError(error) {
    return new _ClerkElementsFieldError(error.code, error.longMessage || error.message);
  }
  get validityState() {
    return this.code;
  }
  get forceMatch() {
    return true;
  }
};

// src/internals/machines/form/form.machine.ts
var FormMachine = (0, import_xstate.setup)({
  actions: {
    setGlobalErrors: (0, import_xstate.assign)({
      errors: (_, params) => [...params.errors]
    }),
    setFieldFeedback: (0, import_xstate.assign)({
      fields: ({ context }, params) => {
        if (!params.name) {
          throw new Error("Field name is required");
        }
        if (context.fields.has(params.name)) {
          context.fields.get(params.name).feedback = params.feedback;
        }
        return context.fields;
      }
    })
  },
  types: {}
}).createMachine({
  id: "Form",
  context: () => ({
    defaultValues: /* @__PURE__ */ new Map(),
    errors: [],
    fields: /* @__PURE__ */ new Map(),
    progressive: false
  }),
  on: {
    "ERRORS.SET": {
      actions: (0, import_xstate.enqueueActions)(({ enqueue, event }) => {
        var _a, _b, _c;
        const isClerkAPIError = (err) => "meta" in err;
        if ((0, import_error.isKnownError)(event.error)) {
          const fields = {};
          const globalErrors = [];
          const errors = (0, import_error.isClerkAPIResponseError)(event.error) ? (_a = event.error) == null ? void 0 : _a.errors : [event.error];
          for (const error of errors) {
            const name = isClerkAPIError(error) ? (0, import_underscore.snakeToCamel)((_b = error.meta) == null ? void 0 : _b.paramName) : null;
            if (!name || (0, import_error.isMetamaskError)(error)) {
              globalErrors.push(ClerkElementsError.fromAPIError(error));
              continue;
            }
            if (!fields[name]) {
              fields[name] = [];
            }
            (_c = fields[name]) == null ? void 0 : _c.push(ClerkElementsFieldError.fromAPIError(error));
          }
          enqueue({
            type: "setGlobalErrors",
            params: {
              errors: globalErrors
            }
          });
          for (const field in fields) {
            enqueue({
              type: "setFieldFeedback",
              params: {
                name: field,
                feedback: {
                  type: "error",
                  message: fields[field][0]
                }
              }
            });
          }
        }
      })
    },
    "ERRORS.CLEAR": {
      actions: (0, import_xstate.assign)({
        errors: () => []
      })
    },
    "FIELD.ADD": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          event.field.value = event.field.value || context.defaultValues.get(event.field.name) || void 0;
          context.fields.set(event.field.name, event.field);
          return context.fields;
        }
      })
    },
    "FIELD.UPDATE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.checked = event.field.checked;
            field.disabled = event.field.disabled || false;
            field.value = event.field.value;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.DISABLE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.disabled = true;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.ENABLE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          const field = context.fields.get(event.field.name);
          if (field) {
            field.disabled = false;
            context.fields.set(event.field.name, field);
          }
          return context.fields;
        }
      })
    },
    "FIELD.REMOVE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          context.fields.delete(event.field.name);
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.SET": {
      actions: [
        {
          type: "setFieldFeedback",
          params: ({ event }) => event.field
        }
      ]
    },
    "FIELD.FEEDBACK.CLEAR": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          if (context.fields.has(event.field.name)) {
            context.fields.get(event.field.name).feedback = void 0;
          }
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.CLEAR.ALL": {
      actions: (0, import_xstate.assign)({
        fields: ({ context }) => {
          context.fields.forEach((field) => {
            field.feedback = void 0;
          });
          return context.fields;
        }
      })
    },
    MARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)(({ event }) => {
        const missing = new Set(event.missing);
        return {
          defaultValues: event.defaultValues,
          hidden: /* @__PURE__ */ new Set([...event.required.filter((f) => !missing.has(f)), ...event.optional]),
          missing,
          optional: new Set(event.optional),
          progressive: true,
          required: new Set(event.required)
        };
      })
    },
    UNMARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)({
        defaultValues: /* @__PURE__ */ new Map(),
        hidden: void 0,
        missing: void 0,
        optional: void 0,
        progressive: false,
        required: void 0
      })
    },
    PREFILL_DEFAULT_VALUES: {
      actions: (0, import_xstate.assign)(({ event }) => {
        return {
          defaultValues: event.defaultValues
        };
      })
    }
  }
});

// src/internals/utils/inspector/index.ts
var inspect;
if (false) {
  inspect = (_a = getBrowserInspector()) != null ? _a : getConsoleInspector();
}

// src/internals/machines/form/form.context.ts
var FormMachineContext = (0, import_react.createActorContext)(FormMachine, { inspect });
var FormStoreProvider = FormMachineContext.Provider;
var useFormStore = FormMachineContext.useActorRef;
var useFormSelector = FormMachineContext.useSelector;
var globalErrorsSelector = (state) => state.context.errors;

// src/internals/machines/sign-in/verification.machine.ts
var import_error2 = require("@clerk/shared/error");
var import_xstate2 = require("xstate");

// src/internals/machines/shared/shared.actions.ts
function sendToLoading({ context, event }) {
  let step;
  let strategy;
  let action;
  if (event.type.startsWith("xstate.done.") || event.type.startsWith("xstate.error.")) {
    return context.parent.send({
      type: "LOADING",
      isLoading: false,
      step: void 0,
      strategy: void 0
    });
  }
  if (context.loadingStep === "strategy") {
    step = void 0;
    if (event.type === "REDIRECT") {
      strategy = event.params.strategy;
    }
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy
    });
  } else if (context.loadingStep === "continue") {
    step = "continue";
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  } else if (context.loadingStep === "reset-password") {
    step = "reset-password";
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  } else if (context.loadingStep === "start") {
    step = "start";
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  } else {
    step = context.loadingStep;
    strategy = void 0;
    action = "action" in event ? event.action : void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy,
      action
    });
  }
}

// src/internals/machines/sign-in/utils/starting-factors.ts
var import_webauthn = require("@clerk/shared/webauthn");
var makeSortingOrderMap = (arr) => arr.reduce(
  (acc, k, i) => {
    acc[k] = i;
    return acc;
  },
  {}
);
var STRATEGY_SORT_ORDER_PASSWORD_PREF = makeSortingOrderMap([
  "passkey",
  "password",
  "email_link",
  "email_code",
  "phone_code"
]);
var STRATEGY_SORT_ORDER_OTP_PREF = makeSortingOrderMap([
  "email_code",
  "email_link",
  "phone_code",
  "passkey",
  "password"
]);
var makeSortingFunction = (sortingMap) => (a, b) => {
  const orderA = sortingMap[a.strategy];
  const orderB = sortingMap[b.strategy];
  if (orderA === void 0 || orderB === void 0) {
    return 0;
  }
  return orderA - orderB;
};
var passwordPrefFactorComparator = makeSortingFunction(STRATEGY_SORT_ORDER_PASSWORD_PREF);
var otpPrefFactorComparator = makeSortingFunction(STRATEGY_SORT_ORDER_OTP_PREF);
var findFactorForIdentifier = (i) => (f) => {
  return "safeIdentifier" in f && f.safeIdentifier === i;
};
function determineStartingSignInFactor(firstFactors, identifier, preferredSignInStrategy) {
  if (!firstFactors || firstFactors.length === 0) {
    return null;
  }
  return preferredSignInStrategy === "password" ? determineStrategyWhenPasswordIsPreferred(firstFactors, identifier) : determineStrategyWhenOTPIsPreferred(firstFactors, identifier);
}
function findPasskeyStrategy(factors) {
  if ((0, import_webauthn.isWebAuthnSupported)()) {
    const passkeyFactor = factors.find(({ strategy }) => strategy === "passkey");
    if (passkeyFactor) {
      return passkeyFactor;
    }
  }
  return null;
}
function determineStrategyWhenPasswordIsPreferred(factors, identifier) {
  const passkeyFactor = findPasskeyStrategy(factors);
  if (passkeyFactor) {
    return passkeyFactor;
  }
  const selected = factors.sort(passwordPrefFactorComparator)[0];
  if (selected.strategy === "password") {
    return selected;
  }
  return factors.find(findFactorForIdentifier(identifier)) || selected || null;
}
function determineStrategyWhenOTPIsPreferred(factors, identifier) {
  const passkeyFactor = findPasskeyStrategy(factors);
  if (passkeyFactor) {
    return passkeyFactor;
  }
  const sortedBasedOnPrefFactor = factors.sort(otpPrefFactorComparator);
  const forIdentifier = sortedBasedOnPrefFactor.find(findFactorForIdentifier(identifier));
  if (forIdentifier) {
    return forIdentifier;
  }
  const firstBasedOnPref = sortedBasedOnPrefFactor[0];
  if (firstBasedOnPref.strategy === "email_link") {
    return firstBasedOnPref;
  }
  return factors.find(findFactorForIdentifier(identifier)) || firstBasedOnPref || null;
}
function determineStartingSignInSecondFactor(secondFactors) {
  if (!secondFactors || secondFactors.length === 0) {
    return null;
  }
  const totpFactor = secondFactors.find((f) => f.strategy === "totp");
  if (totpFactor) {
    return totpFactor;
  }
  const phoneCodeFactor = secondFactors.find((f) => f.strategy === "phone_code");
  if (phoneCodeFactor) {
    return phoneCodeFactor;
  }
  return secondFactors[0];
}

// src/internals/machines/utils/assert.ts
function assertIsDefined(value, label) {
  if (value === void 0 || value === null) {
    throw new Error(`${label || value} is not defined`);
  }
}
function assertActorEventError(event) {
  if ("error" in event === false) {
    throw new Error(`Expected an error event, got "${event.type}"`);
  }
}

// src/internals/machines/sign-in/verification.types.ts
var SignInVerificationDelays = {
  resendableTimeout: 1e3
  // 1 second
};

// src/internals/machines/sign-in/verification.machine.ts
var isNonPreparableStrategy = (strategy) => {
  if (!strategy) {
    return false;
  }
  return ["passkey", "password"].includes(strategy);
};
var SignInVerificationMachineId = "SignInVerification";
var SignInVerificationMachine = (0, import_xstate2.setup)({
  actors: {
    determineStartingFactor: (0, import_xstate2.fromPromise)(
      () => Promise.reject(new ClerkElementsRuntimeError("Actor `determineStartingFactor` must be overridden"))
    ),
    prepare: (0, import_xstate2.fromPromise)(
      () => Promise.reject(new ClerkElementsRuntimeError("Actor `prepare` must be overridden"))
    ),
    attempt: (0, import_xstate2.fromPromise)(
      () => Promise.reject(new ClerkElementsRuntimeError("Actor `attempt` must be overridden"))
    ),
    attemptPasskey: (0, import_xstate2.fromPromise)(({ input: { parent, flow } }) => {
      return parent.getSnapshot().context.clerk.client.signIn.authenticateWithPasskey({
        flow
      });
    })
  },
  actions: {
    resendableTick: (0, import_xstate2.assign)(({ context }) => ({
      resendable: context.resendableAfter === 0,
      resendableAfter: context.resendableAfter > 0 ? context.resendableAfter - 1 : context.resendableAfter
    })),
    resendableReset: (0, import_xstate2.assign)({
      resendable: false,
      resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT
    }),
    validateRegisteredStrategies: ({ context }) => {
      var _a;
      const clerk = context.parent.getSnapshot().context.clerk;
      if ((_a = clerk.__unstable__environment) == null ? void 0 : _a.isProduction()) {
        return;
      }
      if (false) {
        if (clerk.client.signIn.supportedFirstFactors && !clerk.client.signIn.supportedFirstFactors.every((factor) => context.registeredStrategies.has(factor.strategy))) {
          console.warn(
            `Clerk: Your instance is configured to support these strategies: ${clerk.client.signIn.supportedFirstFactors.map((factor) => factor.strategy).join(", ")}, but the rendered strategies are: ${Array.from(context.registeredStrategies).join(
              ", "
            )}. Make sure to render a <Strategy> component for each supported strategy. More information: https://clerk.com/docs/elements/reference/sign-in#strategy`
          );
        }
        if (clerk.client.signIn.supportedSecondFactors && !clerk.client.signIn.supportedSecondFactors.every((factor) => context.registeredStrategies.has(factor.strategy))) {
          console.warn(
            `Clerk: Your instance is configured to support these 2FA strategies: ${clerk.client.signIn.supportedSecondFactors.map((f) => f.strategy).join(", ")}, but the rendered strategies are: ${Array.from(context.registeredStrategies).join(
              ", "
            )}. Make sure to render a <Strategy> component for each supported strategy. More information: https://clerk.com/docs/elements/reference/sign-in#strategy`
          );
        }
        const strategiesUsedButNotActivated = Array.from(context.registeredStrategies).filter(
          (strategy) => !((_a2 = clerk.client.signIn.supportedFirstFactors) == null ? void 0 : _a2.some((supported) => supported.strategy === strategy))
        );
        if (strategiesUsedButNotActivated.length > 0) {
          console.warn(
            `Clerk: These rendered strategies are not configured for your instance: ${strategiesUsedButNotActivated.join(", ")}. If this is unexpected, make sure to enable them in your Clerk dashboard: https://dashboard.clerk.com/last-active?path=/user-authentication/email-phone-username`
          );
        }
        if (((_b = context.currentFactor) == null ? void 0 : _b.strategy) && !context.registeredStrategies.has((_c = context.currentFactor) == null ? void 0 : _c.strategy)) {
          throw new ClerkElementsRuntimeError(
            `Your sign-in attempt is missing a ${(_d = context.currentFactor) == null ? void 0 : _d.strategy} strategy. Make sure <Strategy name="${(_e = context.currentFactor) == null ? void 0 : _e.strategy}"> is rendered in your flow. More information: https://clerk.com/docs/elements/reference/sign-in#strategy`
          );
        } else if (!((_f = context.currentFactor) == null ? void 0 : _f.strategy)) {
          throw new ClerkElementsRuntimeError(
            "Unable to determine an authentication strategy to verify. This means your instance is misconfigured. Visit the Clerk Dashboard and verify that your instance has authentication strategies enabled: https://dashboard.clerk.com/last-active?path=/user-authentication/email-phone-username"
          );
        }
      }
    },
    sendToNext: ({ context, event }) => context.parent.send({ type: "NEXT", resource: event.output }),
    sendToLoading,
    setFormErrors: (0, import_xstate2.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    ),
    setConsoleError: ({ event }) => {
      if (true) {
        return;
      }
      assertActorEventError(event);
      const error = (0, import_error2.isClerkAPIResponseError)(event.error) ? event.error.errors[0].longMessage : event.error.message;
      console.error(`Unable to fulfill the prepare or attempt request for the sign-in verification.
      Error: ${error}
      Please open an issue if you continue to run into this issue.`);
    }
  },
  guards: {
    isResendable: ({ context }) => context.resendable || context.resendableAfter === 0,
    isNeverResendable: ({ context }) => {
      var _a;
      return isNonPreparableStrategy((_a = context.currentFactor) == null ? void 0 : _a.strategy);
    }
  },
  delays: SignInVerificationDelays,
  types: {}
}).createMachine({
  id: SignInVerificationMachineId,
  context: ({ input }) => ({
    currentFactor: null,
    basePath: input.basePath || SIGN_IN_DEFAULT_BASE_PATH,
    formRef: input.formRef,
    loadingStep: "verifications",
    parent: input.parent,
    registeredStrategies: /* @__PURE__ */ new Set(),
    resendable: false,
    resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT
  }),
  initial: "Init",
  on: {
    "NAVIGATE.PREVIOUS": ".Hist",
    "STRATEGY.REGISTER": {
      actions: (0, import_xstate2.assign)({
        registeredStrategies: ({ context, event }) => context.registeredStrategies.add(event.factor)
      })
    },
    "STRATEGY.UNREGISTER": {
      actions: (0, import_xstate2.assign)({
        registeredStrategies: ({ context, event }) => {
          context.registeredStrategies.delete(event.factor);
          return context.registeredStrategies;
        }
      })
    }
  },
  states: {
    Init: {
      tags: ["state:preparing", "state:loading"],
      invoke: {
        id: "determineStartingFactor",
        src: "determineStartingFactor",
        input: ({ context }) => ({
          parent: context.parent
        }),
        onDone: {
          target: "Preparing",
          actions: (0, import_xstate2.assign)({
            currentFactor: ({ event }) => event.output
          })
        },
        onError: {
          target: "Preparing",
          actions: [
            (0, import_xstate2.log)("Clerk [Sign In Verification]: Error determining starting factor"),
            (0, import_xstate2.assign)({
              currentFactor: { strategy: "password" }
            })
          ]
        }
      }
    },
    Preparing: {
      tags: ["state:preparing", "state:loading"],
      invoke: {
        id: "prepare",
        src: "prepare",
        input: ({ context }) => ({
          parent: context.parent,
          resendable: context.resendable,
          params: {
            ...context.currentFactor,
            redirectUrl: `${window.location.origin}${context.basePath}${MAGIC_LINK_VERIFY_PATH_ROUTE}`
          }
        }),
        onDone: {
          actions: "resendableReset",
          target: "Pending"
        },
        onError: {
          actions: ["setFormErrors", "setConsoleError"],
          target: "Pending"
        }
      }
    },
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        "AUTHENTICATE.PASSKEY": {
          guard: (0, import_xstate2.not)("isExampleMode"),
          target: "AttemptingPasskey",
          reenter: true
        },
        "NAVIGATE.CHOOSE_STRATEGY": "ChooseStrategy",
        "NAVIGATE.FORGOT_PASSWORD": "ChooseStrategy",
        RETRY: "Preparing",
        SUBMIT: {
          target: "Attempting",
          reenter: true
        }
      },
      initial: "Init",
      states: {
        Init: {
          description: "Marks appropriate factors as never resendable.",
          always: [
            {
              guard: "isNeverResendable",
              target: "NeverResendable"
            },
            {
              target: "NotResendable"
            }
          ]
        },
        Resendable: {
          description: "Waiting for user to retry"
        },
        NeverResendable: {
          description: "Handles never resendable",
          on: {
            RETRY: {
              actions: (0, import_xstate2.log)("Never retriable")
            }
          }
        },
        NotResendable: {
          description: "Handle countdowns",
          on: {
            RETRY: {
              actions: (0, import_xstate2.log)(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
            }
          },
          after: {
            resendableTimeout: [
              {
                description: "Set as retriable if countdown is 0",
                guard: "isResendable",
                actions: "resendableTick",
                target: "Resendable"
              },
              {
                description: "Continue countdown if not retriable",
                actions: "resendableTick",
                target: "NotResendable",
                reenter: true
              }
            ]
          }
        }
      },
      after: {
        3e3: {
          actions: "validateRegisteredStrategies"
        }
      }
    },
    ChooseStrategy: {
      description: "Handles both choose strategy and forgot password as the latter is similar in functionality",
      tags: ["state:choose-strategy", "state:forgot-password"],
      on: {
        "STRATEGY.UPDATE": {
          actions: (0, import_xstate2.assign)({ currentFactor: ({ event }) => event.factor || null }),
          target: "Preparing"
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attempt",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          currentFactor: context.currentFactor,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "setConsoleError", "sendToLoading"],
          target: "Pending"
        }
      }
    },
    AttemptingPasskey: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attemptPasskey",
        src: "attemptPasskey",
        input: ({ context }) => ({
          parent: context.parent,
          flow: "discoverable"
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    },
    Hist: {
      type: "history"
    }
  }
});
var SignInFirstFactorMachine = SignInVerificationMachine.provide({
  actors: {
    determineStartingFactor: (0, import_xstate2.fromPromise)(async ({ input }) => {
      var _a;
      const clerk = input.parent.getSnapshot().context.clerk;
      return Promise.resolve(
        determineStartingSignInFactor(
          clerk.client.signIn.supportedFirstFactors,
          clerk.client.signIn.identifier,
          (_a = clerk.__unstable__environment) == null ? void 0 : _a.displayConfig.preferredSignInStrategy
        )
      );
    }),
    prepare: (0, import_xstate2.fromPromise)(async ({ input }) => {
      const { params, parent, resendable } = input;
      const clerk = parent.getSnapshot().context.clerk;
      const currentVerificationExpiration = clerk.client.signIn.firstFactorVerification.expireAt;
      const needsPrepare = resendable || !currentVerificationExpiration || currentVerificationExpiration < /* @__PURE__ */ new Date();
      if (isNonPreparableStrategy(params == null ? void 0 : params.strategy) || !needsPrepare) {
        return Promise.resolve(clerk.client.signIn);
      }
      assertIsDefined(params, "First factor params");
      return await clerk.client.signIn.prepareFirstFactor(params);
    }),
    attempt: (0, import_xstate2.fromPromise)(async ({ input }) => {
      var _a, _b, _c, _d;
      const { currentFactor, fields, parent } = input;
      assertIsDefined(currentFactor, "Current factor");
      let attemptParams;
      const strategy = currentFactor.strategy;
      const code = (_a = fields.get("code")) == null ? void 0 : _a.value;
      const password = (_b = fields.get("password")) == null ? void 0 : _b.value;
      switch (strategy) {
        case "passkey": {
          return await parent.getSnapshot().context.clerk.client.signIn.authenticateWithPasskey();
        }
        case "password": {
          assertIsDefined(password, "Password");
          attemptParams = {
            strategy,
            password
          };
          break;
        }
        case "reset_password_phone_code":
        case "reset_password_email_code": {
          assertIsDefined(code, "Code for resetting phone/email");
          attemptParams = {
            strategy,
            code,
            password
          };
          break;
        }
        case "phone_code":
        case "email_code": {
          assertIsDefined(code, "Code for phone/email");
          attemptParams = {
            strategy,
            code
          };
          break;
        }
        case "web3_metamask_signature": {
          const signature = (_c = fields.get("signature")) == null ? void 0 : _c.value;
          assertIsDefined(signature, "Web3 Metamask signature");
          attemptParams = {
            strategy,
            signature
          };
          break;
        }
        case "web3_coinbase_wallet_signature": {
          const signature = (_d = fields.get("signature")) == null ? void 0 : _d.value;
          assertIsDefined(signature, "Web3 Coinbase Wallet signature");
          attemptParams = {
            strategy,
            signature
          };
          break;
        }
        default:
          throw new ClerkElementsRuntimeError(`Invalid strategy: ${strategy}`);
      }
      return await parent.getSnapshot().context.clerk.client.signIn.attemptFirstFactor(attemptParams);
    })
  }
});
var SignInSecondFactorMachine = SignInVerificationMachine.provide({
  actors: {
    determineStartingFactor: (0, import_xstate2.fromPromise)(
      async ({ input }) => Promise.resolve(
        determineStartingSignInSecondFactor(
          input.parent.getSnapshot().context.clerk.client.signIn.supportedSecondFactors
        )
      )
    ),
    prepare: (0, import_xstate2.fromPromise)(async ({ input }) => {
      const { params, parent, resendable } = input;
      const clerk = parent.getSnapshot().context.clerk;
      const currentVerificationExpiration = clerk.client.signIn.secondFactorVerification.expireAt;
      const needsPrepare = resendable || !currentVerificationExpiration || currentVerificationExpiration < /* @__PURE__ */ new Date();
      assertIsDefined(params, "Second factor params");
      if (params.strategy !== "phone_code" || !needsPrepare) {
        return Promise.resolve(clerk.client.signIn);
      }
      return await clerk.client.signIn.prepareSecondFactor({
        strategy: params.strategy,
        phoneNumberId: params.phoneNumberId
      });
    }),
    attempt: (0, import_xstate2.fromPromise)(async ({ input }) => {
      var _a;
      const { fields, parent, currentFactor } = input;
      const code = (_a = fields.get("code")) == null ? void 0 : _a.value;
      assertIsDefined(currentFactor, "Current factor");
      assertIsDefined(code, "Code");
      return await parent.getSnapshot().context.clerk.client.signIn.attemptSecondFactor({
        strategy: currentFactor.strategy,
        code
      });
    })
  }
});

// src/internals/machines/sign-in/router.machine.ts
var import_url = require("@clerk/shared/url");
var import_webauthn2 = require("@clerk/shared/webauthn");
var import_xstate7 = require("xstate");

// src/internals/machines/third-party/third-party.actors.ts
var import_xstate3 = require("xstate");

// src/internals/machines/utils/clerkjs.ts
function isClerkJSEvent(eventObj, event) {
  return Object.values(eventObj).includes(event);
}
var ClerkJSNavigationEvent = {
  complete: "CLERKJS.NAVIGATE.COMPLETE",
  signUp: "CLERKJS.NAVIGATE.SIGN_UP",
  continue: "CLERKJS.NAVIGATE.CONTINUE",
  generic: "CLERKJS.NAVIGATE.GENERIC",
  resetPassword: "CLERKJS.NAVIGATE.RESET_PASSWORD",
  signIn: "CLERKJS.NAVIGATE.SIGN_IN",
  verification: "CLERKJS.NAVIGATE.VERIFICATION"
};
function isClerkJSNavigationEvent(event) {
  return isClerkJSEvent(ClerkJSNavigationEvent, event);
}

// src/internals/machines/third-party/third-party.actors.ts
var redirect = (0, import_xstate3.fromPromise)(
  async ({ input: { flow, params, parent } }) => {
    const clerk = parent.getSnapshot().context.clerk;
    return clerk.client[flow].authenticateWithRedirect({
      redirectUrl: clerk.buildUrlWithAuth(params.redirectUrl || "/"),
      redirectUrlComplete: clerk.buildUrlWithAuth(params.redirectUrlComplete || "/"),
      ...params
    });
  }
);
var handleRedirectCallback = (0, import_xstate3.fromCallback)(
  ({ sendBack, input: parent }) => {
    var _a;
    const clerk = parent.getSnapshot().context.clerk;
    const displayConfig = (_a = clerk.__unstable__environment) == null ? void 0 : _a.displayConfig;
    const customNavigate = (toEvt) => {
      const to = toEvt.split("/").slice(-1)[0];
      if (isClerkJSNavigationEvent(to)) {
        sendBack({ type: to });
      } else if (to === (displayConfig == null ? void 0 : displayConfig.signInUrl)) {
        sendBack({ type: ClerkJSNavigationEvent.signIn });
      } else if (to === (displayConfig == null ? void 0 : displayConfig.signUpUrl)) {
        sendBack({ type: ClerkJSNavigationEvent.signUp });
      } else {
        sendBack({ type: "FAILURE", error: new ClerkElementsRuntimeError(`Unknown navigation event: ${to}`) });
      }
      return Promise.resolve();
    };
    const loadedClerk = clerk.clerkjs;
    void loadedClerk.handleRedirectCallback(
      {
        signInForceRedirectUrl: ClerkJSNavigationEvent.complete,
        signInFallbackRedirectUrl: ClerkJSNavigationEvent.complete,
        signUpForceRedirectUrl: ClerkJSNavigationEvent.signUp,
        signUpFallbackRedirectUrl: ClerkJSNavigationEvent.signUp,
        continueSignUpUrl: ClerkJSNavigationEvent.continue,
        firstFactorUrl: ClerkJSNavigationEvent.signIn,
        resetPasswordUrl: ClerkJSNavigationEvent.resetPassword,
        secondFactorUrl: ClerkJSNavigationEvent.signIn,
        verifyEmailAddressUrl: ClerkJSNavigationEvent.verification,
        verifyPhoneNumberUrl: ClerkJSNavigationEvent.verification,
        signUpUrl: ClerkJSNavigationEvent.signUp,
        signInUrl: ClerkJSNavigationEvent.signIn
      },
      customNavigate
    );
    return () => void 0;
  }
);

// src/internals/machines/third-party/third-party.machine.ts
var import_xstate4 = require("xstate");
var ThirdPartyMachineId = "ThirdParty";
var ThirdPartyMachine = (0, import_xstate4.setup)({
  actors: {
    handleRedirectCallback,
    redirect
  },
  actions: {
    logError: (0, import_xstate4.log)(({ event }) => `Error: ${event.type}`),
    assignActiveStrategy: (0, import_xstate4.assign)({
      activeStrategy: ({ event }) => {
        (0, import_xstate4.assertEvent)(event, "REDIRECT");
        return event.params.strategy;
      }
    }),
    unassignActiveStrategy: (0, import_xstate4.assign)({
      activeStrategy: null
    }),
    sendToNext: ({ context }) => context.parent.send({ type: "NEXT" }),
    sendToLoading,
    setFormErrors: (0, import_xstate4.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isExampleMode: ({ context }) => Boolean(context.parent.getSnapshot().context.exampleMode)
  },
  types: {}
}).createMachine({
  id: ThirdPartyMachineId,
  context: ({ input }) => ({
    activeStrategy: null,
    basePath: input.basePath,
    formRef: input.formRef,
    flow: input.flow,
    parent: input.parent,
    loadingStep: "strategy"
  }),
  initial: "Idle",
  states: {
    Idle: {
      description: "Sets third-party providers if not already set, and waits for a redirect or callback event",
      on: {
        CALLBACK: "HandlingCallback",
        REDIRECT: {
          guard: (0, import_xstate4.not)("isExampleMode"),
          target: "Redirecting",
          reenter: true
        }
      }
    },
    Redirecting: {
      description: "Redirects to the third-party provider for authentication",
      tags: ["state:redirect", "state:loading"],
      entry: ["assignActiveStrategy", "sendToLoading"],
      exit: ["unassignActiveStrategy", "sendToLoading"],
      invoke: {
        id: "redirect",
        src: "redirect",
        input: ({ context, event }) => {
          (0, import_xstate4.assertEvent)(event, "REDIRECT");
          return {
            basePath: context.basePath,
            flow: context.flow,
            params: event.params,
            parent: context.parent
          };
        },
        onError: {
          actions: "setFormErrors",
          target: "Idle"
        }
      }
    },
    HandlingCallback: {
      description: "Handles the callback from the third-party provider",
      tags: ["state:callback", "state:loading"],
      invoke: {
        id: "handleRedirectCallback",
        src: "handleRedirectCallback",
        input: ({ context }) => context.parent,
        onError: {
          actions: ["logError", "setFormErrors"],
          target: "Idle"
        }
      },
      on: {
        "CLERKJS.NAVIGATE.*": {
          actions: "sendToNext",
          target: "Idle"
        }
      }
    }
  }
});

// src/internals/machines/utils/next.ts
function shouldUseVirtualRouting() {
  if (typeof window === "undefined") {
    return false;
  }
  if (!window.next) {
    return false;
  }
  return window.next.version < NEXT_WINDOW_HISTORY_SUPPORT_VERSION;
}

// src/internals/machines/sign-in/reset-password.machine.ts
var import_xstate5 = require("xstate");
var SignInResetPasswordMachineId = "SignInResetPasswordMachine";
var SignInResetPasswordMachine = (0, import_xstate5.setup)({
  actors: {
    attempt: (0, import_xstate5.fromPromise)(
      ({ input: { fields, parent } }) => {
        var _a, _b;
        const password = ((_a = fields.get("password")) == null ? void 0 : _a.value) || "";
        const signOutOfOtherSessions = ((_b = fields.get("signOutOfOtherSessions")) == null ? void 0 : _b.checked) || false;
        return parent.getSnapshot().context.clerk.client.signIn.resetPassword({ password, signOutOfOtherSessions });
      }
    )
  },
  actions: {
    sendToLoading,
    sendToNext: ({ context, event }) => context.parent.send({ type: "NEXT", resource: event.output }),
    setFormErrors: (0, import_xstate5.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  types: {}
}).createMachine({
  id: SignInResetPasswordMachineId,
  context: ({ input }) => ({
    loadingStep: "reset-password",
    parent: input.parent,
    formRef: input.formRef
  }),
  initial: "Pending",
  states: {
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          target: "Attempting",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attempt",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-in/start.machine.ts
var import_xstate6 = require("xstate");
var SignInStartMachineId = "SignInStart";
var SignInStartMachine = (0, import_xstate6.setup)({
  actors: {
    attemptPasskey: (0, import_xstate6.fromPromise)(({ input: { parent, flow } }) => {
      return parent.getSnapshot().context.clerk.client.signIn.authenticateWithPasskey({
        flow
      });
    }),
    attemptWeb3: (0, import_xstate6.fromPromise)(
      ({ input: { parent, strategy } }) => {
        if (strategy === "web3_metamask_signature") {
          return parent.getSnapshot().context.clerk.client.signIn.authenticateWithMetamask();
        }
        if (strategy === "web3_coinbase_wallet_signature") {
          return parent.getSnapshot().context.clerk.client.signIn.authenticateWithCoinbaseWallet();
        }
        throw new ClerkElementsRuntimeError(`Unsupported Web3 strategy: ${strategy}`);
      }
    ),
    attempt: (0, import_xstate6.fromPromise)(
      ({ input: { fields, parent } }) => {
        const clerk = parent.getSnapshot().context.clerk;
        const password = fields.get("password");
        const identifier = fields.get("identifier");
        const passwordParams = (password == null ? void 0 : password.value) ? {
          password: password.value,
          strategy: "password"
        } : {};
        return clerk.client.signIn.create({
          identifier: (identifier == null ? void 0 : identifier.value) || "",
          ...passwordParams
        });
      }
    )
  },
  actions: {
    sendToNext: ({ context, event }) => {
      return context.parent.send({ type: "NEXT", resource: event == null ? void 0 : event.output });
    },
    sendToLoading,
    setFormErrors: (0, import_xstate6.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isExampleMode: ({ context }) => Boolean(context.parent.getSnapshot().context.exampleMode)
  },
  types: {}
}).createMachine({
  id: SignInStartMachineId,
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_IN_DEFAULT_BASE_PATH,
    parent: input.parent,
    formRef: input.formRef,
    loadingStep: "start"
  }),
  initial: "Pending",
  states: {
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          guard: (0, import_xstate6.not)("isExampleMode"),
          target: "Attempting",
          reenter: true
        },
        "AUTHENTICATE.PASSKEY": {
          guard: (0, import_xstate6.not)("isExampleMode"),
          target: "AttemptingPasskey",
          reenter: true
        },
        "AUTHENTICATE.PASSKEY.AUTOFILL": {
          guard: (0, import_xstate6.not)("isExampleMode"),
          target: "AttemptingPasskeyAutoFill",
          reenter: false
        },
        "AUTHENTICATE.WEB3": {
          guard: (0, import_xstate6.not)("isExampleMode"),
          target: "AttemptingWeb3",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attempt",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    },
    AttemptingPasskey: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attemptPasskey",
        src: "attemptPasskey",
        input: ({ context }) => ({
          parent: context.parent,
          flow: "discoverable"
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    },
    AttemptingPasskeyAutoFill: {
      on: {
        "AUTHENTICATE.PASSKEY": {
          guard: (0, import_xstate6.not)("isExampleMode"),
          target: "AttemptingPasskey",
          reenter: true
        },
        SUBMIT: {
          guard: (0, import_xstate6.not)("isExampleMode"),
          target: "Attempting",
          reenter: true
        }
      },
      invoke: {
        id: "attemptPasskeyAutofill",
        src: "attemptPasskey",
        input: ({ context }) => ({
          parent: context.parent,
          flow: "autofill"
        }),
        onDone: {
          actions: ["sendToNext"]
        },
        onError: {
          actions: ["setFormErrors"],
          target: "Pending"
        }
      }
    },
    AttemptingWeb3: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attemptWeb3",
        src: "attemptWeb3",
        input: ({ context, event }) => {
          (0, import_xstate6.assertEvent)(event, "AUTHENTICATE.WEB3");
          return {
            parent: context.parent,
            strategy: event.strategy
          };
        },
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-in/router.machine.ts
var isCurrentPath = (path) => ({ context }, _params) => {
  var _a, _b;
  return (_b = (_a = context.router) == null ? void 0 : _a.match(path)) != null ? _b : false;
};
var needsStatus = (status) => ({ context, event }, _) => {
  var _a, _b;
  return ((_a = event == null ? void 0 : event.resource) == null ? void 0 : _a.status) === status || ((_b = context.clerk) == null ? void 0 : _b.client.signIn.status) === status;
};
var SignInRouterMachineId = "SignInRouter";
var SignInRouterMachine = (0, import_xstate7.setup)({
  actors: {
    firstFactorMachine: SignInFirstFactorMachine,
    formMachine: FormMachine,
    resetPasswordMachine: SignInResetPasswordMachine,
    startMachine: SignInStartMachine,
    secondFactorMachine: SignInSecondFactorMachine,
    thirdPartyMachine: ThirdPartyMachine,
    webAuthnAutofillSupport: (0, import_xstate7.fromPromise)(() => (0, import_webauthn2.isWebAuthnAutofillSupported)())
  },
  actions: {
    clearFormErrors: (0, import_xstate7.sendTo)(({ context }) => context.formRef, { type: "ERRORS.CLEAR" }),
    navigateInternal: ({ context }, { path, force = false }) => {
      if (!context.router) {
        return;
      }
      if (!force && shouldUseVirtualRouting()) {
        return;
      }
      if (context.exampleMode) {
        return;
      }
      const resolvedPath = (0, import_url.joinURL)(context.router.basePath, path);
      if (resolvedPath === context.router.pathname()) {
        return;
      }
      context.router.shallowPush(resolvedPath);
    },
    navigateExternal: ({ context }, { path }) => {
      var _a;
      return (_a = context.router) == null ? void 0 : _a.push(path);
    },
    raiseNext: (0, import_xstate7.raise)({ type: "NEXT" }),
    setActive: (0, import_xstate7.enqueueActions)(({ enqueue, check, context, event }) => {
      if (check("isExampleMode")) {
        return;
      }
      const id = event == null ? void 0 : event.id;
      const lastActiveSessionId = context.clerk.client.lastActiveSessionId;
      const createdSessionId = ((event == null ? void 0 : event.resource) || context.clerk.client.signIn).createdSessionId;
      const session = id || createdSessionId || lastActiveSessionId || null;
      const beforeEmit = () => {
        var _a, _b;
        return (_b = context.router) == null ? void 0 : _b.push(((_a = context.router) == null ? void 0 : _a.searchParams().get("redirect_url")) || context.clerk.buildAfterSignInUrl());
      };
      void context.clerk.setActive({ session, beforeEmit });
      enqueue.raise({ type: "RESET" }, { delay: 2e3 });
    }),
    setError: (0, import_xstate7.assign)({
      error: (_, { error }) => {
        if (error) {
          return error;
        }
        return new ClerkElementsRuntimeError("Unknown error");
      }
    }),
    setFormErrors: ({ context }, params) => (0, import_xstate7.sendTo)(context.formRef, {
      type: "ERRORS.SET",
      error: params.error
    }),
    setFormOAuthErrors: ({ context }) => {
      const errorOrig = context.clerk.client.signIn.firstFactorVerification.error;
      if (!errorOrig) {
        return;
      }
      let error;
      switch (errorOrig.code) {
        case ERROR_CODES.NOT_ALLOWED_TO_SIGN_UP:
        case ERROR_CODES.OAUTH_ACCESS_DENIED:
        case ERROR_CODES.NOT_ALLOWED_ACCESS:
        case ERROR_CODES.SAML_USER_ATTRIBUTE_MISSING:
        case ERROR_CODES.OAUTH_EMAIL_DOMAIN_RESERVED_BY_SAML:
        case ERROR_CODES.USER_LOCKED:
          error = new ClerkElementsError(errorOrig.code, errorOrig.longMessage || "");
          break;
        default:
          error = new ClerkElementsError(
            "unable_to_complete",
            "Unable to complete action at this time. If the problem persists please contact support."
          );
      }
      context.formRef.send({
        type: "ERRORS.SET",
        error
      });
    },
    transfer: ({ context }) => {
      var _a;
      const searchParams = new URLSearchParams({ __clerk_transfer: "1" });
      (_a = context.router) == null ? void 0 : _a.push(`${context.signUpPath}?${searchParams}`);
    }
  },
  guards: {
    hasAuthenticatedViaClerkJS: ({ context }) => Boolean(context.clerk.client.signIn.status === null && context.clerk.client.lastActiveSessionId),
    hasOAuthError: ({ context }) => {
      var _a, _b, _c, _d;
      return Boolean((_d = (_c = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signIn) == null ? void 0 : _c.firstFactorVerification) == null ? void 0 : _d.error);
    },
    hasResource: ({ context }) => {
      var _a, _b, _c;
      return Boolean((_c = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signIn) == null ? void 0 : _c.status);
    },
    isLoggedInAndSingleSession: (0, import_xstate7.and)(["isLoggedIn", "isSingleSessionMode", (0, import_xstate7.not)("isExampleMode")]),
    isActivePathRoot: isCurrentPath("/"),
    isComplete: ({ context, event }) => {
      const resource = event == null ? void 0 : event.resource;
      const signIn = context.clerk.client.signIn;
      return (resource == null ? void 0 : resource.status) === "complete" && Boolean(resource == null ? void 0 : resource.createdSessionId) || signIn.status === "complete" && Boolean(signIn.createdSessionId);
    },
    isLoggedIn: ({ context }) => {
      var _a;
      return Boolean((_a = context.clerk) == null ? void 0 : _a.user);
    },
    isSingleSessionMode: ({ context }) => {
      var _a, _b;
      return Boolean((_b = (_a = context.clerk) == null ? void 0 : _a.__unstable__environment) == null ? void 0 : _b.authConfig.singleSessionMode);
    },
    isExampleMode: ({ context }) => Boolean(context.exampleMode),
    needsStart: (0, import_xstate7.or)([(0, import_xstate7.not)("hasResource"), "statusNeedsIdentifier", isCurrentPath("/")]),
    needsFirstFactor: (0, import_xstate7.and)(["statusNeedsFirstFactor", isCurrentPath("/continue")]),
    needsSecondFactor: (0, import_xstate7.and)(["statusNeedsSecondFactor", isCurrentPath("/continue")]),
    needsCallback: isCurrentPath(SSO_CALLBACK_PATH_ROUTE),
    needsChooseSession: isCurrentPath(CHOOSE_SESSION_PATH_ROUTE),
    needsNewPassword: (0, import_xstate7.and)(["statusNeedsNewPassword", isCurrentPath("/new-password")]),
    statusNeedsIdentifier: needsStatus("needs_identifier"),
    statusNeedsFirstFactor: needsStatus("needs_first_factor"),
    statusNeedsSecondFactor: needsStatus("needs_second_factor"),
    statusNeedsNewPassword: needsStatus("needs_new_password")
  },
  types: {}
}).createMachine({
  id: SignInRouterMachineId,
  // @ts-expect-error - Set in INIT event
  context: {},
  initial: "Idle",
  on: {
    "AUTHENTICATE.OAUTH": {
      actions: (0, import_xstate7.sendTo)(ThirdPartyMachineId, ({ context, event }) => {
        var _a, _b, _c, _d;
        return {
          type: "REDIRECT",
          params: {
            strategy: event.strategy,
            redirectUrl: `${((_a = context.router) == null ? void 0 : _a.mode) === ROUTING.virtual ? (_b = context.clerk.__unstable__environment) == null ? void 0 : _b.displayConfig.signInUrl : (_c = context.router) == null ? void 0 : _c.basePath}${SSO_CALLBACK_PATH_ROUTE}`,
            redirectUrlComplete: ((_d = context.router) == null ? void 0 : _d.searchParams().get("redirect_url")) || context.clerk.buildAfterSignInUrl()
          }
        };
      })
    },
    "AUTHENTICATE.SAML": {
      actions: (0, import_xstate7.sendTo)(ThirdPartyMachineId, ({ context }) => {
        var _a, _b, _c, _d, _e;
        return {
          type: "REDIRECT",
          params: {
            strategy: "saml",
            identifier: (_a = context.formRef.getSnapshot().context.fields.get("identifier")) == null ? void 0 : _a.value,
            redirectUrl: `${((_b = context.router) == null ? void 0 : _b.mode) === ROUTING.virtual ? (_c = context.clerk.__unstable__environment) == null ? void 0 : _c.displayConfig.signInUrl : (_d = context.router) == null ? void 0 : _d.basePath}${SSO_CALLBACK_PATH_ROUTE}`,
            redirectUrlComplete: ((_e = context.router) == null ? void 0 : _e.searchParams().get("redirect_url")) || context.clerk.buildAfterSignInUrl()
          }
        };
      })
    },
    "FORM.ATTACH": {
      description: "Attach/re-attach the form to the router.",
      actions: (0, import_xstate7.enqueueActions)(({ enqueue, event }) => {
        enqueue.assign({
          formRef: event.formRef
        });
        enqueue.raise({ type: "RESET.STEP" });
      })
    },
    "NAVIGATE.PREVIOUS": ".Hist",
    "NAVIGATE.START": ".Start",
    LOADING: {
      actions: (0, import_xstate7.assign)(({ event }) => ({
        loading: {
          isLoading: event.isLoading,
          step: event.step,
          strategy: event.strategy,
          action: event.action
        }
      }))
    },
    RESET: ".Idle"
  },
  states: {
    Idle: {
      invoke: {
        id: "webAuthnAutofill",
        src: "webAuthnAutofillSupport",
        onDone: {
          actions: (0, import_xstate7.assign)({ webAuthnAutofillSupport: ({ event }) => event.output })
        }
      },
      on: {
        INIT: {
          actions: (0, import_xstate7.assign)(({ event }) => ({
            clerk: event.clerk,
            exampleMode: event.exampleMode || false,
            formRef: event.formRef,
            loading: {
              isLoading: false
            },
            router: event.router,
            signUpPath: event.signUpPath || SIGN_UP_DEFAULT_BASE_PATH
          })),
          target: "Init"
        }
      }
    },
    Init: {
      entry: (0, import_xstate7.enqueueActions)(({ context, enqueue, self }) => {
        var _a, _b;
        if (!self.getSnapshot().children[ThirdPartyMachineId]) {
          enqueue.spawnChild("thirdPartyMachine", {
            id: ThirdPartyMachineId,
            systemId: ThirdPartyMachineId,
            input: {
              basePath: (_b = (_a = context.router) == null ? void 0 : _a.basePath) != null ? _b : SIGN_IN_DEFAULT_BASE_PATH,
              flow: "signIn",
              formRef: context.formRef,
              parent: self
            }
          });
        }
      }),
      always: [
        {
          guard: "needsCallback",
          target: "Callback"
        },
        {
          guard: "needsChooseSession",
          target: "ChooseSession"
        },
        {
          guard: "isComplete",
          actions: "setActive"
        },
        {
          guard: "isLoggedInAndSingleSession",
          actions: [
            (0, import_xstate7.log)("Already logged in"),
            {
              type: "navigateExternal",
              params: ({ context }) => {
                var _a;
                return {
                  path: ((_a = context.router) == null ? void 0 : _a.searchParams().get("redirect_url")) || context.clerk.buildAfterSignInUrl()
                };
              }
            }
          ]
        },
        {
          guard: "needsStart",
          actions: { type: "navigateInternal", params: { force: true, path: "/" } },
          target: "Start"
        },
        {
          guard: "needsFirstFactor",
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } },
          target: "FirstFactor"
        },
        {
          guard: "needsSecondFactor",
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } },
          target: "SecondFactor"
        },
        {
          guard: "needsNewPassword",
          actions: { type: "navigateInternal", params: { force: true, path: "/reset-password" } },
          target: "ResetPassword"
        },
        {
          actions: { type: "navigateInternal", params: { force: true, path: "/" } },
          target: "Start"
        }
      ]
    },
    Start: {
      tags: ["step:start"],
      exit: "clearFormErrors",
      invoke: {
        id: "start",
        src: "startMachine",
        input: ({ context, self }) => {
          var _a;
          return {
            basePath: (_a = context.router) == null ? void 0 : _a.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "Start",
          reenter: true
        },
        "AUTHENTICATE.PASSKEY": {
          actions: (0, import_xstate7.sendTo)("start", ({ event }) => event)
        },
        "AUTHENTICATE.PASSKEY.AUTOFILL": {
          actions: (0, import_xstate7.sendTo)("start", ({ event }) => event)
        },
        "AUTHENTICATE.WEB3": {
          actions: (0, import_xstate7.sendTo)("start", ({ event }) => event)
        },
        NEXT: [
          {
            guard: "isComplete",
            actions: "setActive"
          },
          {
            guard: "statusNeedsFirstFactor",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "FirstFactor"
          },
          {
            guard: "statusNeedsSecondFactor",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "SecondFactor"
          },
          {
            guard: "statusNeedsNewPassword",
            actions: { type: "navigateInternal", params: { path: "/reset-password" } },
            target: "ResetPassword"
          }
        ]
      }
    },
    FirstFactor: {
      tags: ["step:first-factor", "step:verifications"],
      invoke: {
        id: "firstFactor",
        src: "firstFactorMachine",
        input: ({ context, self }) => {
          var _a;
          return {
            formRef: context.formRef,
            parent: self,
            basePath: (_a = context.router) == null ? void 0 : _a.basePath
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "AUTHENTICATE.PASSKEY": {
          actions: (0, import_xstate7.sendTo)("firstFactor", ({ event }) => event)
        },
        "RESET.STEP": {
          target: "FirstFactor",
          reenter: true
        },
        NEXT: [
          {
            guard: "isComplete",
            actions: "setActive"
          },
          {
            guard: "statusNeedsSecondFactor",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "SecondFactor"
          },
          {
            guard: "statusNeedsNewPassword",
            actions: { type: "navigateInternal", params: { path: "/reset-password" } },
            target: "ResetPassword"
          }
        ],
        "STRATEGY.UPDATE": {
          description: "Send event to verification machine to update the current strategy.",
          actions: (0, import_xstate7.sendTo)("firstFactor", ({ event }) => event),
          target: ".Idle"
        }
      },
      initial: "Idle",
      states: {
        Idle: {
          on: {
            "NAVIGATE.FORGOT_PASSWORD": {
              description: "Navigate to forgot password screen.",
              actions: (0, import_xstate7.sendTo)("firstFactor", ({ event }) => event),
              target: "ForgotPassword"
            },
            "NAVIGATE.CHOOSE_STRATEGY": {
              description: "Navigate to choose strategy screen.",
              actions: (0, import_xstate7.sendTo)("firstFactor", ({ event }) => event),
              target: "ChoosingStrategy"
            }
          }
        },
        ChoosingStrategy: {
          tags: ["step:choose-strategy"],
          on: {
            "NAVIGATE.PREVIOUS": {
              description: "Go to Idle, and also tell firstFactor to go to Pending",
              target: "Idle",
              actions: (0, import_xstate7.sendTo)("firstFactor", { type: "NAVIGATE.PREVIOUS" })
            }
          }
        },
        ForgotPassword: {
          tags: ["step:forgot-password"],
          on: {
            "NAVIGATE.PREVIOUS": "Idle"
          }
        }
      }
    },
    SecondFactor: {
      tags: ["step:second-factor", "step:verifications"],
      invoke: {
        id: "secondFactor",
        src: "secondFactorMachine",
        input: ({ context, self }) => ({
          formRef: context.formRef,
          parent: self
        }),
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "SecondFactor",
          reenter: true
        },
        NEXT: [
          {
            guard: "isComplete",
            actions: "setActive"
          },
          {
            guard: "statusNeedsNewPassword",
            actions: { type: "navigateInternal", params: { path: "/reset-password" } },
            target: "ResetPassword"
          }
        ],
        "STRATEGY.UPDATE": {
          description: "Send event to verification machine to update the current strategy.",
          actions: (0, import_xstate7.sendTo)("secondFactor", ({ event }) => event),
          target: ".Idle"
        }
      },
      initial: "Idle",
      states: {
        Idle: {
          on: {
            "NAVIGATE.CHOOSE_STRATEGY": {
              description: "Navigate to choose strategy screen.",
              actions: (0, import_xstate7.sendTo)("secondFactor", ({ event }) => event),
              target: "ChoosingStrategy"
            }
          }
        },
        ChoosingStrategy: {
          tags: ["step:choose-strategy"],
          on: {
            "NAVIGATE.PREVIOUS": {
              description: "Go to Idle, and also tell firstFactor to go to Pending",
              target: "Idle",
              actions: (0, import_xstate7.sendTo)("secondFactor", { type: "NAVIGATE.PREVIOUS" })
            }
          }
        }
      }
    },
    ResetPassword: {
      tags: ["step:reset-password"],
      invoke: {
        id: "resetPassword",
        src: "resetPasswordMachine",
        input: ({ context, self }) => ({
          formRef: context.formRef,
          parent: self
        }),
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "ResetPassword",
          reenter: true
        },
        NEXT: [
          {
            guard: "isComplete",
            actions: "setActive"
          },
          {
            guard: "statusNeedsFirstFactor",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "FirstFactor"
          },
          {
            guard: "statusNeedsSecondFactor",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "SecondFactor"
          }
        ]
      }
    },
    Callback: {
      tags: ["step:callback"],
      entry: (0, import_xstate7.sendTo)(ThirdPartyMachineId, { type: "CALLBACK" }),
      on: {
        NEXT: [
          {
            guard: "hasOAuthError",
            actions: ["setFormOAuthErrors", { type: "navigateInternal", params: { force: true, path: "/" } }],
            target: "Start"
          },
          {
            guard: (0, import_xstate7.or)(["isLoggedIn", "isComplete", "hasAuthenticatedViaClerkJS"]),
            actions: "setActive"
          },
          {
            guard: "statusNeedsIdentifier",
            actions: "transfer"
          },
          {
            guard: "statusNeedsFirstFactor",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "FirstFactor"
          },
          {
            guard: "statusNeedsSecondFactor",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "SecondFactor"
          },
          {
            guard: "statusNeedsNewPassword",
            actions: { type: "navigateInternal", params: { path: "/reset-password" } },
            target: "ResetPassword"
          }
        ]
      }
    },
    ChooseSession: {
      tags: ["step:choose-session"],
      on: {
        "SESSION.SET_ACTIVE": {
          actions: {
            type: "setActive",
            params: ({ event }) => ({ id: event.id })
          }
        }
      }
    },
    Error: {
      tags: ["step:error"],
      on: {
        NEXT: {
          target: "Start",
          actions: "clearFormErrors"
        }
      }
    },
    Hist: {
      type: "history",
      exit: "clearFormErrors"
    }
  }
});

// src/internals/machines/utils/formatters.ts
var import_underscore2 = require("@clerk/shared/underscore");
function formatName(...args) {
  switch (args.length) {
    case 0:
      return void 0;
    case 1:
      return (0, import_underscore2.titleize)(args[0]);
    default:
      return args.filter(Boolean).map(import_underscore2.titleize).join(" ");
  }
}
function formatSalutation({
  firstName,
  lastName,
  identifier
}) {
  return firstName && formatName(firstName) || lastName && formatName(lastName) || identifier || "";
}

// src/internals/machines/sign-in/router.selectors.ts
function SignInSafeIdentifierSelectorForStrategy(strategy) {
  return (s) => {
    var _a, _b, _c;
    const signIn = (_a = s.context.clerk) == null ? void 0 : _a.client.signIn;
    if (strategy) {
      const matchingFactors = [
        ...(_b = signIn.supportedFirstFactors) != null ? _b : [],
        ...(_c = signIn.supportedSecondFactors) != null ? _c : []
      ].filter((f) => f.strategy === strategy);
      const matchingFactorForIdentifier = signIn.identifier && matchingFactors.length > 0 ? matchingFactors.find((f) => "safeIdentifier" in f && f.safeIdentifier === signIn.identifier) : null;
      const matchingFactorForStrategy = matchingFactors[0];
      if (matchingFactorForIdentifier && "safeIdentifier" in matchingFactorForIdentifier) {
        return matchingFactorForIdentifier.safeIdentifier;
      }
      if (matchingFactorForStrategy && "safeIdentifier" in matchingFactorForStrategy) {
        return matchingFactorForStrategy.safeIdentifier;
      }
    }
    return signIn.identifier || "";
  };
}
function SignInSalutationSelector(s) {
  var _a, _b, _c;
  const signIn = (_a = s.context.clerk) == null ? void 0 : _a.client.signIn;
  return formatSalutation({
    firstName: (_b = signIn == null ? void 0 : signIn.userData) == null ? void 0 : _b.firstName,
    identifier: signIn == null ? void 0 : signIn.identifier,
    lastName: (_c = signIn == null ? void 0 : signIn.userData) == null ? void 0 : _c.lastName
  });
}

// src/internals/machines/sign-in/router.types.ts
var SignInRouterSystemId = {
  start: "start",
  firstFactor: "firstFactor",
  secondFactor: "secondFactor",
  resetPassword: "resetPassword"
};

// src/react/router/index.ts
var import_router3 = require("@clerk/shared/router");

// src/react/router/virtual.ts
var import_react2 = require("react");
var DUMMY_ORIGIN = "https://clerk.dummy";
var _url, _listeners;
var VirtualRouter = class {
  constructor(path) {
    this.name = "VirtualRouter";
    this.mode = "virtual";
    __privateAdd(this, _url);
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    const origin = typeof window === "undefined" ? DUMMY_ORIGIN : window.location.origin;
    __privateSet(this, _url, new URL(path != null ? path : "/", origin));
  }
  push(path) {
    const newUrl = new URL(__privateGet(this, _url).toString());
    newUrl.pathname = path;
    __privateSet(this, _url, newUrl);
    this.emit();
  }
  replace(path) {
    this.push(path);
  }
  shallowPush(path) {
    this.push(path);
  }
  pathname() {
    return __privateGet(this, _url).pathname;
  }
  searchParams() {
    return __privateGet(this, _url).searchParams;
  }
  subscribe(listener) {
    __privateGet(this, _listeners).add(listener);
    return () => __privateGet(this, _listeners).delete(listener);
  }
  emit() {
    __privateGet(this, _listeners).forEach((listener) => listener(__privateGet(this, _url)));
  }
  getSnapshot() {
    return __privateGet(this, _url);
  }
};
_url = new WeakMap();
_listeners = new WeakMap();
var virtualRouter = new VirtualRouter("/");
var useVirtualRouter = () => {
  const url = (0, import_react2.useSyncExternalStore)(
    virtualRouter.subscribe.bind(virtualRouter),
    virtualRouter.getSnapshot.bind(virtualRouter)
  );
  return {
    mode: virtualRouter.mode,
    name: virtualRouter.name,
    pathname: () => url.pathname,
    push: virtualRouter.push.bind(virtualRouter),
    replace: virtualRouter.replace.bind(virtualRouter),
    searchParams: () => url.searchParams,
    shallowPush: virtualRouter.shallowPush.bind(virtualRouter)
  };
};

// src/react/utils/create-context-from-actor-ref.ts
var import_react3 = require("@xstate/react");
var React = __toESM(require("react"));
function createContextFromActorRef(displayName) {
  const ReactContext = React.createContext(null);
  const OriginalProvider = ReactContext.Provider;
  function Provider({ children, actorRef }) {
    return React.createElement(
      OriginalProvider,
      {
        value: actorRef
      },
      children
    );
  }
  Provider.displayName = displayName;
  function useContext6(allowMissingActor = false) {
    const actorRef = React.useContext(ReactContext);
    if (!allowMissingActor && !actorRef) {
      throw new Error(
        `You used a hook from "${Provider.displayName}" but it's not inside a <${Provider.displayName}.Provider> component.`
      );
    }
    return actorRef;
  }
  function useSelector6(selector, compare) {
    const actor2 = useContext6();
    return (0, import_react3.useSelector)(actor2, selector, compare);
  }
  return {
    Provider,
    useActorRef: useContext6,
    useSelector: useSelector6
  };
}

// src/react/sign-in/context/router.context.ts
var SignInRouterCtx = createContextFromActorRef("SignInRouterCtx");
function useSignInStep(name) {
  return SignInRouterCtx.useSelector((state) => state.children[name]);
}
var useSignInStartStep = () => useSignInStep("start");
var useSignInFirstFactorStep = () => useSignInStep("firstFactor");
var useSignInSecondFactorStep = () => useSignInStep("secondFactor");
var useSignInResetPasswordStep = () => useSignInStep("resetPassword");

// src/react/sign-in/context/sign-in-strategy.context.ts
var import_react4 = require("react");
var SignInStrategyContext = (0, import_react4.createContext)({
  strategy: void 0
});
function useSignInStrategy() {
  const ctx = (0, import_react4.useContext)(SignInStrategyContext);
  if (!ctx) {
    throw new ClerkElementsRuntimeError(
      "useSignInStrategy must be used within a <SignIn.Strategy> or <SignIn.SupportedStrategy> component."
    );
  }
  const { strategy } = ctx;
  return strategy;
}

// src/react/sign-in/context/strategies.context.ts
var import_react5 = require("react");
var StrategiesContext = (0, import_react5.createContext)({
  current: void 0,
  isActive: (_name) => false,
  preferred: void 0
});
function useStrategy(name) {
  const ctx = (0, import_react5.useContext)(StrategiesContext);
  if (!ctx) {
    throw new ClerkElementsRuntimeError(
      'useStrategy must be used within a <SignIn.Step name="verifications"> component. Did you mean to `import { Step } from "@clerk/elements/sign-up"` instead?'
    );
  }
  const { current, preferred, isActive } = ctx;
  return {
    current,
    preferred,
    get active() {
      return isActive(name);
    }
  };
}

// src/react/common/form/hooks/use-form.ts
var import_react6 = require("react");

// src/react/common/form/hooks/use-global-errors.ts
function useGlobalErrors() {
  const errors = useFormSelector(globalErrorsSelector);
  return {
    errors
  };
}

// src/react/common/form/hooks/use-form.ts
function useForm({ flowActor }) {
  const { errors } = useGlobalErrors();
  const onSubmit = (0, import_react6.useCallback)(
    (event) => {
      event.preventDefault();
      if (flowActor) {
        flowActor.send({ type: "SUBMIT", action: "submit" });
      }
    },
    [flowActor]
  );
  return {
    props: {
      ...errors.length > 0 ? { "data-global-error": true } : {},
      onSubmit
    }
  };
}

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// src/react/common/form/form.tsx
var import_react_form = require("@radix-ui/react-form");
var React2 = __toESM(require("react"));
var import_jsx_runtime = require("react/jsx-runtime");
var DISPLAY_NAME = "ClerkElementsForm";
var Form = React2.forwardRef(({ flowActor, onSubmit, ...rest }, forwardedRef) => {
  const form = useForm({ flowActor });
  const { onSubmit: internalOnSubmit, ...internalFormProps } = form.props;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_react_form.Form,
    {
      ...internalFormProps,
      ...rest,
      onSubmit: composeEventHandlers(internalOnSubmit, onSubmit),
      ref: forwardedRef
    }
  );
});
Form.displayName = DISPLAY_NAME;

// src/react/common/form/submit.tsx
var import_react_form2 = require("@radix-ui/react-form");
var DISPLAY_NAME2 = "ClerkElementsSubmit";
var Submit = import_react_form2.Submit;
Submit.displayName = DISPLAY_NAME2;

// src/react/utils/path-inference/next.tsx
var import_router5 = require("next/compat/router");
var import_navigation = require("next/navigation");
var import_react7 = __toESM(require("react"));

// src/react/utils/path-inference/utils.ts
function removeOptionalCatchAllSegment(pathname) {
  return pathname.replace(/\/\[\[\.\.\..*/, "");
}

// src/react/utils/path-inference/next.tsx
var usePathnameWithoutCatchAll = () => {
  const pathRef = import_react7.default.useRef();
  const pagesRouter = (0, import_router5.useRouter)();
  if (pagesRouter) {
    if (pathRef.current) {
      return pathRef.current;
    } else {
      pathRef.current = removeOptionalCatchAllSegment(pagesRouter.pathname);
      return pathRef.current;
    }
  }
  const pathname = (0, import_navigation.usePathname)() || "";
  const pathParts = pathname.split("/").filter(Boolean);
  const catchAllParams = Object.values((0, import_navigation.useParams)() || {}).filter((v) => Array.isArray(v)).flat(Infinity);
  if (pathRef.current) {
    return pathRef.current;
  } else {
    pathRef.current = `/${pathParts.slice(0, pathParts.length - catchAllParams.length).join("/")}`;
    return pathRef.current;
  }
};

// src/react/sign-in/root.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var actor = (0, import_xstate8.createActor)(SignInRouterMachine, { inspect });
actor.start();
function SignInFlowProvider({ children, exampleMode, fallback, isRootPath }) {
  const clerk = (0, import_react8.useClerk)();
  const router = (0, import_router3.useClerkRouter)();
  const formRef = useFormStore();
  const isReady = (0, import_react9.useSelector)(actor, (state) => state.value !== "Idle");
  (0, import_react10.useEffect)(() => {
    if (!clerk || !router) {
      return;
    }
    const cb = () => {
      const evt = {
        type: "INIT",
        clerk,
        exampleMode,
        formRef,
        router,
        signUpPath: SIGN_UP_DEFAULT_BASE_PATH
      };
      if (actor.getSnapshot().can(evt)) {
        actor.send(evt);
      }
    };
    if ("addOnLoaded" in clerk) {
      clerk.addOnLoaded(cb);
    } else {
      cb();
    }
    if (formRef && actor.getSnapshot().can({ type: "RESET.STEP" })) {
      actor.send({
        type: "FORM.ATTACH",
        formRef
      });
    }
  }, [clerk, exampleMode, formRef == null ? void 0 : formRef.id, !!router, clerk.loaded]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(SignInRouterCtx.Provider, { actorRef: actor, children: [
    isRootPath && !isReady && fallback ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Form, { children: fallback }) : null,
    clerk.loaded && isReady ? children : null
  ] });
}
function SignInRoot({
  children,
  exampleMode = false,
  fallback = null,
  path: pathProp,
  routing = ROUTING.path
}) {
  var _a;
  const clerk = (0, import_react8.useClerk)();
  const inferredPath = usePathnameWithoutCatchAll();
  const path = pathProp || inferredPath || SIGN_IN_DEFAULT_BASE_PATH;
  (_a = clerk.telemetry) == null ? void 0 : _a.record(
    (0, import_telemetry.eventComponentMounted)("Elements_SignInRoot", {
      exampleMode,
      fallback: Boolean(fallback),
      path,
      routing
    })
  );
  const router = (routing === ROUTING.virtual ? useVirtualRouter : import_router6.useClerkHostRouter)();
  const isRootPath = path === router.pathname();
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    import_router3.Router,
    {
      basePath: path,
      router,
      children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(FormStoreProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        SignInFlowProvider,
        {
          exampleMode,
          fallback,
          isRootPath,
          children
        }
      ) })
    }
  );
}

// src/react/sign-in/step.tsx
var import_react15 = require("@clerk/shared/react");
var import_telemetry2 = require("@clerk/shared/telemetry");

// src/react/sign-in/choose-session/choose-session.tsx
var import_react_slot = require("@radix-ui/react-slot");
var React8 = __toESM(require("react"));

// src/react/utils/create-context-for-dom-validation.ts
var React5 = __toESM(require("react"));
function createContextForDomValidation(displayName) {
  const ReactContext = React5.createContext(false);
  const OriginalProvider = ReactContext.Provider;
  function Provider({ children }) {
    return React5.createElement(
      OriginalProvider,
      {
        value: true
      },
      children
    );
  }
  Provider.displayName = displayName;
  function useContext6(allowMissingContext = false) {
    const context = React5.useContext(ReactContext);
    if (!allowMissingContext && !context) {
      throw new Error(
        `You used a hook from "${Provider.displayName}" but it's not inside a <${Provider.displayName}.Provider> component.`
      );
    }
    return context;
  }
  return {
    Provider,
    useDomValidation: useContext6
  };
}

// src/react/utils/is-valid-component-type.ts
var React6 = __toESM(require("react"));
function isValidComponentType(child, type) {
  return React6.isValidElement(child) && child.type === type;
}

// src/react/sign-in/choose-session/choose-session.hooks.ts
var React7 = __toESM(require("react"));

// src/react/hooks/use-active-tags.hook.ts
var import_react11 = require("@xstate/react");
var ActiveTagsMode = {
  any: "any",
  all: "all"
};
function useActiveTags(actor2, tags, mode = ActiveTagsMode.any) {
  const state = (0, import_react11.useSelector)(
    actor2,
    (s) => s,
    (prev, next) => prev.tags === next.tags
  );
  if (!state) {
    return false;
  }
  if (typeof tags === "string") {
    return state.hasTag(tags);
  }
  if (!Array.isArray(tags)) {
    throw new Error("Invalid tags parameter provided to useActiveTags");
  }
  switch (mode) {
    case ActiveTagsMode.any: {
      const matching = new Set(tags.filter((tag) => state.hasTag(tag)));
      return { active: matching.size > 0, activeTags: matching };
    }
    case ActiveTagsMode.all:
      return tags.length === state.tags.size ? tags.every((tag) => state.hasTag(tag)) : false;
    default:
      return false;
  }
}

// src/react/sign-in/choose-session/choose-session.hooks.ts
var SignInActiveSessionContext = React7.createContext(null);
function useSignInActiveSessionContext() {
  const ctx = React7.useContext(SignInActiveSessionContext);
  if (!ctx) {
    throw new Error("SignInActiveSessionContext must be used within a SessionList/SignInSessionListItem");
  }
  return ctx;
}
function useSignInChooseSessionIsActive() {
  const routerRef = SignInRouterCtx.useActorRef();
  return useActiveTags(routerRef, "step:choose-session");
}
function useSignInActiveSessionList(params) {
  const { omitCurrent = true } = params || {};
  return SignInRouterCtx.useSelector((state) => {
    var _a, _b, _c, _d;
    const activeSessions = ((_b = (_a = state.context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.activeSessions) || [];
    const currentSessionId = (_d = (_c = state.context.clerk) == null ? void 0 : _c.session) == null ? void 0 : _d.id;
    const filteredSessions = omitCurrent ? activeSessions.filter((s) => s.id !== currentSessionId) : activeSessions;
    return filteredSessions.map((s) => ({
      id: s.id,
      ...s.publicUserData
    }));
  });
}

// src/react/sign-in/choose-session/choose-session.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var SignInChooseSessionCtx = createContextForDomValidation("SignInChooseSessionCtx");
function SignInChooseSession({ asChild, children, ...props }) {
  const activeState = useSignInChooseSessionIsActive();
  const Comp = asChild ? import_react_slot.Slot : "div";
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SignInChooseSessionCtx.Provider, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Comp, { ...props, children }) }) : null;
}
function SignInSessionList({ asChild, children, includeCurrentSession, ...props }) {
  const sessions = useSignInActiveSessionList({ omitCurrent: !includeCurrentSession });
  if (!children || !(sessions == null ? void 0 : sessions.length)) {
    return null;
  }
  if (React8.Children.count(children) > 1) {
    return React8.Children.only(null);
  }
  if (asChild && isValidComponentType(children, SignInSessionListItem)) {
    throw new Error("asChild cannot be used with SessionListItem as the direct child");
  }
  if (!React8.isValidElement(children)) {
    throw new Error("children must be a valid React element");
  }
  const newChildren = asChild ? children.props.children : children;
  const childrenWithCtx = sessions.map((session) => {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      SignInActiveSessionContext.Provider,
      {
        value: session,
        children: newChildren
      },
      `SignInActiveSessionContext-${session.id}`
    );
  });
  if (asChild) {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react_slot.Slot, { ...props, children: React8.cloneElement(children, void 0, childrenWithCtx) });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("ul", { ...props, children: childrenWithCtx });
}
function SignInSessionListItem(props) {
  const { asChild = false, children, ...passthroughProps } = props;
  const session = useSignInActiveSessionContext();
  const Comp = asChild ? import_react_slot.Slot : "li";
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Comp, { ...passthroughProps, children: children({ session }) });
}

// src/react/sign-in/choose-strategy.tsx
var import_react_slot2 = require("@radix-ui/react-slot");
var import_react12 = require("@xstate/react");
var React9 = __toESM(require("react"));
var import_jsx_runtime4 = require("react/jsx-runtime");
var SignInChooseStrategyCtx = createContextForDomValidation("SignInChooseStrategyCtx");
function SignInChooseStrategy({ asChild, children, ...props }) {
  const routerRef = SignInRouterCtx.useActorRef();
  const activeStateFirstFactor = useActiveTags(
    routerRef,
    ["step:verifications", "step:first-factor", "step:choose-strategy"],
    ActiveTagsMode.all
  );
  const activeStateSecondFactor = useActiveTags(
    routerRef,
    ["step:verifications", "step:second-factor", "step:choose-strategy"],
    ActiveTagsMode.all
  );
  const activeState = activeStateFirstFactor || activeStateSecondFactor;
  const Comp = asChild ? import_react_slot2.Slot : "div";
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SignInChooseStrategyCtx.Provider, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Comp, { ...props, children }) }) : null;
}
function SignInForgotPassword({ asChild, children, ...props }) {
  const routerRef = SignInRouterCtx.useActorRef();
  const activeState = useActiveTags(
    routerRef,
    ["step:verifications", "step:first-factor", "step:forgot-password"],
    ActiveTagsMode.all
  );
  const Comp = asChild ? import_react_slot2.Slot : "div";
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SignInChooseStrategyCtx.Provider, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Comp, { ...props, children }) }) : null;
}
var SUPPORTED_STRATEGY_NAME = "SignInSupportedStrategy";
var SignInSupportedStrategy = React9.forwardRef(
  ({ asChild, children, name, ...rest }, forwardedRef) => {
    const routerRef = SignInRouterCtx.useActorRef();
    const snapshot = routerRef.getSnapshot();
    const status = snapshot.context.clerk.client.signIn.status;
    const supportedFirstFactors = status === "needs_first_factor" ? snapshot.context.clerk.client.signIn.supportedFirstFactors || [] : [];
    const supportedSecondFactors = status === "needs_second_factor" ? snapshot.context.clerk.client.signIn.supportedSecondFactors || [] : [];
    const factor = [...supportedFirstFactors, ...supportedSecondFactors].find((factor2) => name === factor2.strategy);
    const currentFactor = (0, import_react12.useSelector)(
      snapshot.children[SignInRouterSystemId.firstFactor] || snapshot.children[SignInRouterSystemId.secondFactor],
      (state) => {
        var _a;
        return (_a = state == null ? void 0 : state.context.currentFactor) == null ? void 0 : _a.strategy;
      }
    );
    const sendUpdateStrategyEvent = React9.useCallback(
      () => routerRef.send({ type: "STRATEGY.UPDATE", factor }),
      [routerRef, factor]
    );
    if (currentFactor === name) {
      return null;
    }
    const Comp = asChild ? import_react_slot2.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    return factor ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SignInStrategyContext.Provider, { value: { strategy: name }, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        ref: forwardedRef,
        onClick: sendUpdateStrategyEvent,
        children: children || factor.strategy
      }
    ) }) : null;
  }
);
SignInSupportedStrategy.displayName = SUPPORTED_STRATEGY_NAME;

// src/react/sign-in/reset-password.tsx
var import_jsx_runtime5 = require("react/jsx-runtime");
var SignInResetPasswordCtx = createContextFromActorRef("SignInResetPasswordCtx");
function SignInResetPassword(props) {
  const routerRef = SignInRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "step:reset-password");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SignInResetPasswordInner, { ...props }) : null;
}
function SignInResetPasswordInner(props) {
  const ref = useSignInResetPasswordStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SignInResetPasswordCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}

// src/react/sign-in/start.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var SignInStartCtx = createContextFromActorRef("SignInStartCtx");
function SignInStart(props) {
  const routerRef = SignInRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "step:start");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SignInStartInner, { ...props }) : null;
}
function SignInStartInner(props) {
  const ref = useSignInStartStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SignInStartCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}

// src/react/sign-in/verifications.tsx
var import_react13 = require("@xstate/react");
var import_react14 = require("react");

// src/internals/machines/utils/strategies.ts
var matchStrategy = (current, desired) => {
  if (!current || !desired) {
    return false;
  }
  if (current === desired) {
    return true;
  }
  return current.startsWith(`${desired}_`);
};

// src/react/sign-in/verifications.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var SignInFirstFactorCtx = createContextFromActorRef("SignInFirstFactorCtx");
var SignInSecondFactorCtx = createContextFromActorRef("SignInSecondFactorCtx");
var strategiesSelector = (state) => {
  var _a;
  return (_a = state.context.currentFactor) == null ? void 0 : _a.strategy;
};
function SignInStrategiesProvider({
  children,
  preferred,
  actorRef,
  ...props
}) {
  const routerRef = SignInRouterCtx.useActorRef();
  const current = (0, import_react13.useSelector)(actorRef, strategiesSelector);
  const isChoosingAltStrategy = useActiveTags(routerRef, ["step:choose-strategy", "step:forgot-password"]);
  const isActive = (0, import_react14.useCallback)((name) => current ? matchStrategy(current, name) : false, [current]);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(StrategiesContext.Provider, { value: { current, preferred, isActive }, children: isChoosingAltStrategy.active ? null : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    Form,
    {
      flowActor: actorRef,
      ...props,
      children
    }
  ) });
}
function useFactorCtx() {
  const firstFactorRef = SignInFirstFactorCtx.useActorRef(true);
  const secondFactorRef = SignInSecondFactorCtx.useActorRef(true);
  return firstFactorRef || secondFactorRef;
}
function SignInStrategy({ children, name }) {
  const { active } = useStrategy(name);
  const factorCtx = useFactorCtx();
  (0, import_react14.useEffect)(() => {
    if (factorCtx) {
      factorCtx.send({ type: "STRATEGY.REGISTER", factor: name });
    }
    return () => {
      if ((factorCtx == null ? void 0 : factorCtx.getSnapshot().status) === "active") {
        factorCtx.send({ type: "STRATEGY.UNREGISTER", factor: name });
      }
    };
  }, [factorCtx, name]);
  return active ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignInStrategyContext.Provider, { value: { strategy: name }, children }) : null;
}
function SignInVerifications(props) {
  const routerRef = SignInRouterCtx.useActorRef();
  const { activeTags: activeRoutes } = useActiveTags(routerRef, ["step:first-factor", "step:second-factor"]);
  if (activeRoutes.has("step:first-factor")) {
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignInFirstFactorInner, { ...props });
  }
  if (activeRoutes.has("step:second-factor")) {
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignInSecondFactorInner, { ...props });
  }
  return null;
}
function SignInFirstFactor(props) {
  const routerRef = SignInRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "step:first-factor");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignInFirstFactorInner, { ...props }) : null;
}
function SignInSecondFactor(props) {
  const routerRef = SignInRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "step:second-factor");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignInSecondFactorInner, { ...props }) : null;
}
function SignInFirstFactorInner(props) {
  const ref = useSignInFirstFactorStep();
  if (!ref) {
    return null;
  }
  return ref ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignInFirstFactorCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    SignInStrategiesProvider,
    {
      actorRef: ref,
      ...props
    }
  ) }) : null;
}
function SignInSecondFactorInner(props) {
  const ref = useSignInSecondFactorStep();
  if (!ref) {
    return null;
  }
  return ref ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignInSecondFactorCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    SignInStrategiesProvider,
    {
      actorRef: ref,
      ...props
    }
  ) }) : null;
}

// src/react/sign-in/step.tsx
var import_jsx_runtime8 = require("react/jsx-runtime");
var SIGN_IN_STEPS = {
  start: "start",
  verifications: "verifications",
  "choose-strategy": "choose-strategy",
  "choose-session": "choose-session",
  "forgot-password": "forgot-password",
  "reset-password": "reset-password"
};
function SignInStep(props) {
  var _a;
  const clerk = (0, import_react15.useClerk)();
  (_a = clerk.telemetry) == null ? void 0 : _a.record((0, import_telemetry2.eventComponentMounted)("Elements_SignInStep", { name: props.name }));
  switch (props.name) {
    case SIGN_IN_STEPS.start:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignInStart, { ...props });
    case SIGN_IN_STEPS.verifications:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignInVerifications, { ...props });
    case SIGN_IN_STEPS["choose-strategy"]:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignInChooseStrategy, { ...props });
    case SIGN_IN_STEPS["forgot-password"]:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignInForgotPassword, { ...props });
    case SIGN_IN_STEPS["reset-password"]:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignInResetPassword, { ...props });
    case SIGN_IN_STEPS["choose-session"]:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignInChooseSession, { ...props });
    default:
      throw new ClerkElementsRuntimeError(`Invalid step name. Use: ${Object.keys(SIGN_IN_STEPS).join(",")}.`);
  }
}

// src/react/sign-in/action/action.tsx
var React13 = __toESM(require("react"));

// src/react/common/index.ts
var import_client_only = require("client-only");

// src/react/sign-in/action/navigate.tsx
var import_react_slot3 = require("@radix-ui/react-slot");
var React10 = __toESM(require("react"));
var import_jsx_runtime9 = require("react/jsx-runtime");
var SIGN_IN_NAVIGATE_NAME = "SignInNavigate";
var SignInNavigationEventMap = {
  start: "NAVIGATE.START",
  previous: "NAVIGATE.PREVIOUS",
  "choose-strategy": "NAVIGATE.CHOOSE_STRATEGY",
  "forgot-password": "NAVIGATE.FORGOT_PASSWORD"
};
var SignInNavigate = React10.forwardRef(
  ({ asChild, to, ...rest }, forwardedRef) => {
    const actorRef = SignInRouterCtx.useActorRef();
    const Comp = asChild ? import_react_slot3.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    const sendEvent = React10.useCallback(() => {
      const type = SignInNavigationEventMap[to];
      if (actorRef.getSnapshot().can({ type })) {
        actorRef.send({ type });
      } else {
        console.warn(
          `Clerk: <SignIn.Action navigate="${to}"> is an invalid navigation event. You can only navigate to: ${Object.keys(SignInNavigationEventMap).join(", ")}.`
        );
      }
    }, [actorRef, to]);
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        onClick: sendEvent,
        ref: forwardedRef
      }
    );
  }
);
SignInNavigate.displayName = SIGN_IN_NAVIGATE_NAME;

// src/react/sign-in/action/resend.tsx
var import_react_slot4 = require("@radix-ui/react-slot");
var import_react16 = require("@xstate/react");
var React11 = __toESM(require("react"));
var import_jsx_runtime10 = require("react/jsx-runtime");
var SIGN_IN_RESEND_NAME = "SignInResend";
var SignInResend = React11.forwardRef(
  ({ asChild, fallback, ...rest }, forwardedRef) => {
    const firstFactorRef = SignInFirstFactorCtx.useActorRef(true);
    const secondFactorRef = SignInSecondFactorCtx.useActorRef(true);
    const actorRef = firstFactorRef || secondFactorRef;
    if (!actorRef) {
      throw new Error('The resend action must be used within <SignIn.Step name="verifications">.');
    }
    const fallbackProps = (0, import_react16.useSelector)(
      actorRef,
      (state) => ({
        resendable: state.context.resendable,
        resendableAfter: state.context.resendableAfter
      }),
      (a, b) => a.resendableAfter === b.resendableAfter && a.resendable === b.resendable
    );
    if (fallback && !fallbackProps.resendable) {
      return typeof fallback === "function" ? fallback(fallbackProps) : fallback;
    }
    const Comp = asChild ? import_react_slot4.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        disabled: !fallbackProps.resendable,
        onClick: () => actorRef.send({ type: "RETRY" }),
        ref: forwardedRef
      }
    );
  }
);
SignInResend.displayName = SIGN_IN_RESEND_NAME;

// src/react/sign-in/action/set-active-session.tsx
var import_react_slot5 = require("@radix-ui/react-slot");
var React12 = __toESM(require("react"));
var import_jsx_runtime11 = require("react/jsx-runtime");
var DISPLAY_NAME3 = "SignInSetActiveSession";
var SignInSetActiveSession = React12.forwardRef(
  ({ asChild, ...rest }, forwardedRef) => {
    const actorRef = SignInRouterCtx.useActorRef();
    const session = useSignInActiveSessionContext();
    const Comp = asChild ? import_react_slot5.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    const sendEvent = React12.useCallback(() => {
      const event = { type: "SESSION.SET_ACTIVE", id: session.id };
      if (actorRef.getSnapshot().can(event)) {
        actorRef.send(event);
      } else {
        console.warn(
          `Clerk: <SignIn.Action setActiveSession> is an invalid event. You can only choose an active session from <SignIn.Step name="choose-session">.`
        );
      }
    }, [actorRef, session.id]);
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        onClick: sendEvent,
        ref: forwardedRef
      }
    );
  }
);
SignInSetActiveSession.displayName = DISPLAY_NAME3;

// src/react/sign-in/action/action.tsx
var import_jsx_runtime12 = require("react/jsx-runtime");
var DISPLAY_NAME4 = "SignInAction";
var SignInAction = React13.forwardRef((props, forwardedRef) => {
  const { submit, navigate, resend, setActiveSession, ...rest } = props;
  let Comp;
  if (submit) {
    Comp = Submit;
  } else if (navigate) {
    Comp = SignInNavigate;
  } else if (resend) {
    Comp = SignInResend;
  } else if (setActiveSession) {
    Comp = SignInSetActiveSession;
  }
  return Comp ? /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
    Comp,
    {
      to: navigate,
      ...rest,
      ref: forwardedRef
    }
  ) : null;
});
SignInAction.displayName = DISPLAY_NAME4;

// src/react/sign-in/passkey.tsx
var import_react_slot6 = require("@radix-ui/react-slot");
var React14 = __toESM(require("react"));
var import_jsx_runtime13 = require("react/jsx-runtime");
var SIGN_IN_PASSKEY_NAME = "SignInPasskey";
var SignInPasskey = React14.forwardRef(
  ({ asChild, ...rest }, forwardedRef) => {
    const actorRef = SignInRouterCtx.useActorRef(true);
    const Comp = asChild ? import_react_slot6.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    const sendEvent = React14.useCallback(() => {
      actorRef == null ? void 0 : actorRef.send({ type: "AUTHENTICATE.PASSKEY" });
    }, [actorRef]);
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        onClick: sendEvent,
        ref: forwardedRef
      }
    );
  }
);
SignInPasskey.displayName = SIGN_IN_PASSKEY_NAME;

// src/react/sign-in/identifiers.tsx
var import_react17 = require("react");
function SignInSafeIdentifier({ transform }) {
  const strategy = useSignInStrategy();
  const selector = (0, import_react17.useMemo)(() => SignInSafeIdentifierSelectorForStrategy(strategy), [strategy]);
  const safeIdentifier = SignInRouterCtx.useSelector(selector);
  if (transform) {
    return transform(safeIdentifier);
  }
  return safeIdentifier;
}
function SignInSalutation() {
  return SignInRouterCtx.useSelector(SignInSalutationSelector);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Action,
  FirstFactor,
  Passkey,
  Root,
  SafeIdentifier,
  Salutation,
  SecondFactor,
  SessionList,
  SessionListItem,
  SignIn,
  Step,
  Strategy,
  SupportedStrategy
});
//# sourceMappingURL=index.js.map